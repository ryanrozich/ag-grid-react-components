{
  "timestamp": "2025-07-06T16:02:43.537Z",
  "message": "Implemented PresetManager component with all tests passing",
  "gitStatus": "A  .bot/checkpoint-1751814310827.json\nM  .bot/context.json\nM  .bot/memory.md\nM  src/components/FilterPresets/PresetSelector/PresetSelector.test.tsx\nM  src/components/FilterPresets/PresetSelector/index.tsx\nM  src/components/FilterPresets/SavePresetDialog/SavePresetDialog.test.tsx\nA  src/components/FilterPresets/hooks/usePresets.test.ts\nAM src/components/FilterPresets/hooks/usePresets.ts\nMM src/components/FilterPresets/index.ts\nMM src/components/FilterPresets/types.ts\n?? src/components/FilterPresets/PresetManager/\n",
  "gitDiff": "diff --git a/src/components/FilterPresets/hooks/usePresets.ts b/src/components/FilterPresets/hooks/usePresets.ts\nindex 62c1627..5d6ff03 100644\n--- a/src/components/FilterPresets/hooks/usePresets.ts\n+++ b/src/components/FilterPresets/hooks/usePresets.ts\n@@ -249,13 +249,16 @@ export function usePresets({\n         }\n \n         const importedPresets: FilterPreset[] = parsed.presets.map(\n-          (p: any) => ({\n-            ...p,\n-            id: generateId(), // Generate new IDs to avoid conflicts\n-            createdAt: new Date(p.createdAt || Date.now()),\n-            updatedAt: new Date(p.updatedAt || Date.now()),\n-            isDefault: false, // Don't import default status\n-          }),\n+          (p: unknown) => {\n+            const preset = p as Record<string, unknown>;\n+            return {\n+              ...preset,\n+              id: generateId(), // Generate new IDs to avoid conflicts\n+              createdAt: new Date((preset.createdAt as string) || Date.now()),\n+              updatedAt: new Date((preset.updatedAt as string) || Date.now()),\n+              isDefault: false, // Don't import default status\n+            } as FilterPreset;\n+          },\n         );\n \n         const newTotal = userPresets.length + importedPresets.length;\ndiff --git a/src/components/FilterPresets/index.ts b/src/components/FilterPresets/index.ts\nindex c270d0f..e03d3bb 100644\n--- a/src/components/FilterPresets/index.ts\n+++ b/src/components/FilterPresets/index.ts\n@@ -1,5 +1,5 @@\n export * from \"./types\";\n export { PresetSelector } from \"./PresetSelector\";\n export { SavePresetDialog } from \"./SavePresetDialog\";\n-// export { PresetManager } from \"./PresetManager\"; // TODO: uncomment when implemented\n+export { PresetManager } from \"./PresetManager\";\n export { usePresets } from \"./hooks/usePresets\";\ndiff --git a/src/components/FilterPresets/types.ts b/src/components/FilterPresets/types.ts\nindex 59cbd07..bb0789b 100644\n--- a/src/components/FilterPresets/types.ts\n+++ b/src/components/FilterPresets/types.ts\n@@ -1,7 +1,7 @@\n import type { ReactNode } from \"react\";\n \n // Type for AG Grid v33+ filter models\n-export type FilterModelV33 = Record<string, any>;\n+export type FilterModelV33 = Record<string, unknown>;\n \n export interface FilterPreset {\n   id: string;\n",
  "gitDiffStaged": "diff --git a/.bot/checkpoint-1751814310827.json b/.bot/checkpoint-1751814310827.json\nnew file mode 100644\nindex 0000000..ec0f6c1\n--- /dev/null\n+++ b/.bot/checkpoint-1751814310827.json\n@@ -0,0 +1,17 @@\n+{\n+  \"timestamp\": \"2025-07-06T15:05:10.826Z\",\n+  \"message\": \"Implemented usePresets hook with all tests passing\",\n+  \"gitStatus\": \" M src/components/FilterPresets/PresetSelector/PresetSelector.test.tsx\\n M src/components/FilterPresets/PresetSelector/index.tsx\\n M src/components/FilterPresets/SavePresetDialog/SavePresetDialog.test.tsx\\n M src/components/FilterPresets/index.ts\\n M src/components/FilterPresets/types.ts\\n?? src/components/FilterPresets/hooks/\\n\",\n+  \"gitDiff\": \"diff --git a/src/components/FilterPresets/PresetSelector/PresetSelector.test.tsx b/src/components/FilterPresets/PresetSelector/PresetSelector.test.tsx\\nindex caf8ec8..0ebe044 100644\\n--- a/src/components/FilterPresets/PresetSelector/PresetSelector.test.tsx\\n+++ b/src/components/FilterPresets/PresetSelector/PresetSelector.test.tsx\\n@@ -1,5 +1,5 @@\\n import { describe, it, expect, vi, beforeEach } from \\\"vitest\\\";\\n-import { render, screen, fireEvent, waitFor } from \\\"@testing-library/react\\\";\\n+import { render, screen, waitFor } from \\\"@testing-library/react\\\";\\n import userEvent from \\\"@testing-library/user-event\\\";\\n import { PresetSelector } from \\\"./index\\\";\\n import type { FilterPreset, PresetSelectorProps } from \\\"../types\\\";\\n@@ -253,7 +253,6 @@ describe(\\\"PresetSelector\\\", () => {\\n       render(<PresetSelector {...defaultProps} />);\\n \\n       await user.click(screen.getByRole(\\\"button\\\"));\\n-      const listbox = screen.getByRole(\\\"listbox\\\");\\n \\n       await user.keyboard(\\\"{ArrowDown}\\\");\\n       expect(\\ndiff --git a/src/components/FilterPresets/PresetSelector/index.tsx b/src/components/FilterPresets/PresetSelector/index.tsx\\nindex 70a1d85..df49edd 100644\\n--- a/src/components/FilterPresets/PresetSelector/index.tsx\\n+++ b/src/components/FilterPresets/PresetSelector/index.tsx\\n@@ -151,7 +151,9 @@ export function PresetSelector({\\n             return (\\n               <li\\n                 key={preset.id}\\n-                ref={(el) => (optionRefs.current[index] = el)}\\n+                ref={(el) => {\\n+                  optionRefs.current[index] = el;\\n+                }}\\n                 role=\\\"option\\\"\\n                 id={`preset-option-${preset.id}`}\\n                 aria-selected={isActive}\\ndiff --git a/src/components/FilterPresets/SavePresetDialog/SavePresetDialog.test.tsx b/src/components/FilterPresets/SavePresetDialog/SavePresetDialog.test.tsx\\nindex 12ed234..1dea521 100644\\n--- a/src/components/FilterPresets/SavePresetDialog/SavePresetDialog.test.tsx\\n+++ b/src/components/FilterPresets/SavePresetDialog/SavePresetDialog.test.tsx\\n@@ -1,8 +1,8 @@\\n import { describe, it, expect, vi, beforeEach } from \\\"vitest\\\";\\n-import { render, screen, fireEvent, waitFor } from \\\"@testing-library/react\\\";\\n+import { render, screen, waitFor } from \\\"@testing-library/react\\\";\\n import userEvent from \\\"@testing-library/user-event\\\";\\n import { SavePresetDialog } from \\\"./index\\\";\\n-import type { SavePresetDialogProps, SavePresetFormData } from \\\"../types\\\";\\n+import type { SavePresetDialogProps } from \\\"../types\\\";\\n \\n const mockFilterModel = {\\n   date: { type: \\\"after\\\", mode: \\\"relative\\\", expressionFrom: \\\"Today-7d\\\" },\\ndiff --git a/src/components/FilterPresets/index.ts b/src/components/FilterPresets/index.ts\\nindex e03d3bb..c270d0f 100644\\n--- a/src/components/FilterPresets/index.ts\\n+++ b/src/components/FilterPresets/index.ts\\n@@ -1,5 +1,5 @@\\n export * from \\\"./types\\\";\\n export { PresetSelector } from \\\"./PresetSelector\\\";\\n export { SavePresetDialog } from \\\"./SavePresetDialog\\\";\\n-export { PresetManager } from \\\"./PresetManager\\\";\\n+// export { PresetManager } from \\\"./PresetManager\\\"; // TODO: uncomment when implemented\\n export { usePresets } from \\\"./hooks/usePresets\\\";\\ndiff --git a/src/components/FilterPresets/types.ts b/src/components/FilterPresets/types.ts\\nindex 762d608..59cbd07 100644\\n--- a/src/components/FilterPresets/types.ts\\n+++ b/src/components/FilterPresets/types.ts\\n@@ -1,5 +1,7 @@\\n import type { ReactNode } from \\\"react\\\";\\n-import type { FilterModelV33 } from \\\"../interfaces\\\";\\n+\\n+// Type for AG Grid v33+ filter models\\n+export type FilterModelV33 = Record<string, any>;\\n \\n export interface FilterPreset {\\n   id: string;\\n\",\n+  \"gitDiffStaged\": \"\",\n+  \"context\": {\n+    \"issue\": 48,\n+    \"branch\": \"feature/48-create-ui-components-for-filter-preset-management\",\n+    \"worktree\": \"/Users/ryan/ag-grid-worktrees/feature/48-create-ui-components-for-filter-preset-management\",\n+    \"createdAt\": \"2025-07-06T14:15:36.623Z\",\n+    \"status\": \"initialized\",\n+    \"lastCheckpoint\": \"2025-07-06T15:05:10.826Z\",\n+    \"checkpointMessage\": \"Implemented usePresets hook with all tests passing\",\n+    \"checkpoints\": 4\n+  }\n+}\ndiff --git a/.bot/context.json b/.bot/context.json\nindex fc13b8a..d2c8f92 100644\n--- a/.bot/context.json\n+++ b/.bot/context.json\n@@ -4,7 +4,7 @@\n   \"worktree\": \"/Users/ryan/ag-grid-worktrees/feature/48-create-ui-components-for-filter-preset-management\",\n   \"createdAt\": \"2025-07-06T14:15:36.623Z\",\n   \"status\": \"initialized\",\n-  \"lastCheckpoint\": \"2025-07-06T14:56:43.391Z\",\n-  \"checkpointMessage\": \"Implemented SavePresetDialog component with all tests passing\",\n-  \"checkpoints\": 3\n+  \"lastCheckpoint\": \"2025-07-06T15:05:10.826Z\",\n+  \"checkpointMessage\": \"Implemented usePresets hook with all tests passing\",\n+  \"checkpoints\": 4\n }\ndiff --git a/.bot/memory.md b/.bot/memory.md\nindex 28cf062..a168664 100644\n--- a/.bot/memory.md\n+++ b/.bot/memory.md\n@@ -17,3 +17,7 @@\n ## 2025-07-06T14:56:43.391Z\n \n - **Checkpoint**: Implemented SavePresetDialog component with all tests passing\n+\n+## 2025-07-06T15:05:10.826Z\n+\n+- **Checkpoint**: Implemented usePresets hook with all tests passing\ndiff --git a/src/components/FilterPresets/PresetSelector/PresetSelector.test.tsx b/src/components/FilterPresets/PresetSelector/PresetSelector.test.tsx\nindex caf8ec8..0ebe044 100644\n--- a/src/components/FilterPresets/PresetSelector/PresetSelector.test.tsx\n+++ b/src/components/FilterPresets/PresetSelector/PresetSelector.test.tsx\n@@ -1,5 +1,5 @@\n import { describe, it, expect, vi, beforeEach } from \"vitest\";\n-import { render, screen, fireEvent, waitFor } from \"@testing-library/react\";\n+import { render, screen, waitFor } from \"@testing-library/react\";\n import userEvent from \"@testing-library/user-event\";\n import { PresetSelector } from \"./index\";\n import type { FilterPreset, PresetSelectorProps } from \"../types\";\n@@ -253,7 +253,6 @@ describe(\"PresetSelector\", () => {\n       render(<PresetSelector {...defaultProps} />);\n \n       await user.click(screen.getByRole(\"button\"));\n-      const listbox = screen.getByRole(\"listbox\");\n \n       await user.keyboard(\"{ArrowDown}\");\n       expect(\ndiff --git a/src/components/FilterPresets/PresetSelector/index.tsx b/src/components/FilterPresets/PresetSelector/index.tsx\nindex 70a1d85..df49edd 100644\n--- a/src/components/FilterPresets/PresetSelector/index.tsx\n+++ b/src/components/FilterPresets/PresetSelector/index.tsx\n@@ -151,7 +151,9 @@ export function PresetSelector({\n             return (\n               <li\n                 key={preset.id}\n-                ref={(el) => (optionRefs.current[index] = el)}\n+                ref={(el) => {\n+                  optionRefs.current[index] = el;\n+                }}\n                 role=\"option\"\n                 id={`preset-option-${preset.id}`}\n                 aria-selected={isActive}\ndiff --git a/src/components/FilterPresets/SavePresetDialog/SavePresetDialog.test.tsx b/src/components/FilterPresets/SavePresetDialog/SavePresetDialog.test.tsx\nindex 12ed234..1dea521 100644\n--- a/src/components/FilterPresets/SavePresetDialog/SavePresetDialog.test.tsx\n+++ b/src/components/FilterPresets/SavePresetDialog/SavePresetDialog.test.tsx\n@@ -1,8 +1,8 @@\n import { describe, it, expect, vi, beforeEach } from \"vitest\";\n-import { render, screen, fireEvent, waitFor } from \"@testing-library/react\";\n+import { render, screen, waitFor } from \"@testing-library/react\";\n import userEvent from \"@testing-library/user-event\";\n import { SavePresetDialog } from \"./index\";\n-import type { SavePresetDialogProps, SavePresetFormData } from \"../types\";\n+import type { SavePresetDialogProps } from \"../types\";\n \n const mockFilterModel = {\n   date: { type: \"after\", mode: \"relative\", expressionFrom: \"Today-7d\" },\ndiff --git a/src/components/FilterPresets/hooks/usePresets.test.ts b/src/components/FilterPresets/hooks/usePresets.test.ts\nnew file mode 100644\nindex 0000000..258e46a\n--- /dev/null\n+++ b/src/components/FilterPresets/hooks/usePresets.test.ts\n@@ -0,0 +1,563 @@\n+import { describe, it, expect, vi, beforeEach, afterEach } from \"vitest\";\n+import { renderHook, act, waitFor } from \"@testing-library/react\";\n+import { usePresets } from \"./usePresets\";\n+import type { FilterPreset, PresetStorage } from \"../types\";\n+\n+const mockSystemPresets: FilterPreset[] = [\n+  {\n+    id: \"system-1\",\n+    name: \"Default View\",\n+    filterModel: {},\n+    isSystem: true,\n+    isDefault: true,\n+  },\n+  {\n+    id: \"system-2\",\n+    name: \"Recent Items\",\n+    filterModel: {\n+      date: { type: \"after\", mode: \"relative\", expressionFrom: \"Today-7d\" },\n+    },\n+    isSystem: true,\n+  },\n+];\n+\n+const mockUserPresets: FilterPreset[] = [\n+  {\n+    id: \"user-1\",\n+    name: \"My Filter\",\n+    description: \"Custom filter\",\n+    tags: [\"custom\"],\n+    filterModel: { status: { type: \"equals\", value: \"active\" } },\n+    createdAt: new Date(\"2023-01-01\"),\n+    updatedAt: new Date(\"2023-01-01\"),\n+  },\n+];\n+\n+describe(\"usePresets\", () => {\n+  let mockStorage: PresetStorage;\n+  let mockOnPresetChange: ReturnType<typeof vi.fn>;\n+\n+  beforeEach(() => {\n+    mockStorage = {\n+      load: vi.fn().mockResolvedValue(mockUserPresets),\n+      save: vi.fn().mockResolvedValue(undefined),\n+      getStorageInfo: vi\n+        .fn()\n+        .mockResolvedValue({ used: 50, total: 100, percentage: 50 }),\n+    };\n+    mockOnPresetChange = vi.fn();\n+  });\n+\n+  afterEach(() => {\n+    vi.clearAllMocks();\n+  });\n+\n+  describe(\"Initialization\", () => {\n+    it(\"should load presets from storage on mount\", async () => {\n+      const { result } = renderHook(() =>\n+        usePresets({ storage: mockStorage, systemPresets: mockSystemPresets }),\n+      );\n+\n+      expect(result.current.isLoading).toBe(true);\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      expect(mockStorage.load).toHaveBeenCalled();\n+      expect(result.current.presets).toHaveLength(3); // 2 system + 1 user\n+      expect(result.current.error).toBeNull();\n+    });\n+\n+    it(\"should combine system and user presets\", async () => {\n+      const { result } = renderHook(() =>\n+        usePresets({ storage: mockStorage, systemPresets: mockSystemPresets }),\n+      );\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      const systemPresets = result.current.presets.filter((p) => p.isSystem);\n+      const userPresets = result.current.presets.filter((p) => !p.isSystem);\n+\n+      expect(systemPresets).toHaveLength(2);\n+      expect(userPresets).toHaveLength(1);\n+    });\n+\n+    it(\"should handle storage load errors\", async () => {\n+      const error = new Error(\"Storage failed\");\n+      mockStorage.load = vi.fn().mockRejectedValue(error);\n+\n+      const { result } = renderHook(() => usePresets({ storage: mockStorage }));\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      expect(result.current.error).toBe(error);\n+      expect(result.current.presets).toEqual([]);\n+    });\n+\n+    it(\"should work without storage\", () => {\n+      const { result } = renderHook(() =>\n+        usePresets({ systemPresets: mockSystemPresets }),\n+      );\n+\n+      expect(result.current.isLoading).toBe(false);\n+      expect(result.current.presets).toEqual(mockSystemPresets);\n+    });\n+  });\n+\n+  describe(\"Preset Selection\", () => {\n+    it(\"should select a preset\", async () => {\n+      const { result } = renderHook(() =>\n+        usePresets({\n+          storage: mockStorage,\n+          systemPresets: mockSystemPresets,\n+          onPresetChange: mockOnPresetChange,\n+        }),\n+      );\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      act(() => {\n+        result.current.selectPreset(\"user-1\");\n+      });\n+\n+      expect(result.current.activePresetId).toBe(\"user-1\");\n+      expect(mockOnPresetChange).toHaveBeenCalledWith(mockUserPresets[0]);\n+    });\n+\n+    it(\"should clear selection when null is passed\", async () => {\n+      const { result } = renderHook(() =>\n+        usePresets({\n+          storage: mockStorage,\n+          onPresetChange: mockOnPresetChange,\n+        }),\n+      );\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      act(() => {\n+        result.current.selectPreset(\"user-1\");\n+      });\n+\n+      act(() => {\n+        result.current.selectPreset(null);\n+      });\n+\n+      expect(result.current.activePresetId).toBeNull();\n+      expect(mockOnPresetChange).toHaveBeenLastCalledWith(null);\n+    });\n+\n+    it(\"should not select non-existent preset\", async () => {\n+      const { result } = renderHook(() => usePresets({ storage: mockStorage }));\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      act(() => {\n+        result.current.selectPreset(\"non-existent\");\n+      });\n+\n+      expect(result.current.activePresetId).toBeNull();\n+    });\n+  });\n+\n+  describe(\"Save Preset\", () => {\n+    it(\"should save a new preset\", async () => {\n+      const { result } = renderHook(() => usePresets({ storage: mockStorage }));\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      const newPreset = {\n+        name: \"New Preset\",\n+        description: \"Test preset\",\n+        filterModel: { test: { type: \"equals\", value: \"test\" } },\n+      };\n+\n+      await act(async () => {\n+        await result.current.savePreset(newPreset);\n+      });\n+\n+      expect(mockStorage.save).toHaveBeenCalled();\n+      const savedPresets = (mockStorage.save as any).mock.calls[0][0];\n+      expect(savedPresets).toHaveLength(2); // Original user preset + new one\n+\n+      const saved = savedPresets.find(\n+        (p: FilterPreset) => p.name === \"New Preset\",\n+      );\n+      expect(saved).toBeDefined();\n+      expect(saved.id).toBeDefined();\n+      expect(saved.createdAt).toBeInstanceOf(Date);\n+      expect(saved.updatedAt).toBeInstanceOf(Date);\n+    });\n+\n+    it(\"should set preset as default when isDefault is true\", async () => {\n+      const { result } = renderHook(() =>\n+        usePresets({ storage: mockStorage, systemPresets: mockSystemPresets }),\n+      );\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      const newPreset = {\n+        name: \"New Default\",\n+        filterModel: {},\n+        isDefault: true,\n+      };\n+\n+      await act(async () => {\n+        await result.current.savePreset(newPreset);\n+      });\n+\n+      const savedPresets = (mockStorage.save as any).mock.calls[0][0];\n+      const newDefault = savedPresets.find(\n+        (p: FilterPreset) => p.name === \"New Default\",\n+      );\n+      const oldDefault = savedPresets.find(\n+        (p: FilterPreset) => p.id === \"system-1\",\n+      );\n+\n+      expect(newDefault.isDefault).toBe(true);\n+      expect(oldDefault?.isDefault).toBeUndefined(); // System presets don't get modified\n+    });\n+\n+    it(\"should handle save errors\", async () => {\n+      const error = new Error(\"Save failed\");\n+      mockStorage.save = vi.fn().mockRejectedValue(error);\n+\n+      const { result } = renderHook(() => usePresets({ storage: mockStorage }));\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      await expect(\n+        result.current.savePreset({ name: \"Test\", filterModel: {} }),\n+      ).rejects.toThrow(\"Save failed\");\n+    });\n+\n+    it(\"should respect maxPresets limit\", async () => {\n+      const { result } = renderHook(() =>\n+        usePresets({ storage: mockStorage, maxPresets: 1 }),\n+      );\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      await expect(\n+        result.current.savePreset({ name: \"Over Limit\", filterModel: {} }),\n+      ).rejects.toThrow(/maximum number of presets/i);\n+    });\n+  });\n+\n+  describe(\"Update Preset\", () => {\n+    it(\"should update an existing preset\", async () => {\n+      const { result } = renderHook(() => usePresets({ storage: mockStorage }));\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      await act(async () => {\n+        await result.current.updatePreset(\"user-1\", {\n+          name: \"Updated Name\",\n+          description: \"Updated description\",\n+        });\n+      });\n+\n+      expect(mockStorage.save).toHaveBeenCalled();\n+      const savedPresets = (mockStorage.save as any).mock.calls[0][0];\n+      const updated = savedPresets.find((p: FilterPreset) => p.id === \"user-1\");\n+\n+      expect(updated.name).toBe(\"Updated Name\");\n+      expect(updated.description).toBe(\"Updated description\");\n+      expect(updated.updatedAt).toBeInstanceOf(Date);\n+      expect(updated.updatedAt.getTime()).toBeGreaterThan(\n+        new Date(\"2023-01-01\").getTime(),\n+      );\n+    });\n+\n+    it(\"should not update system presets\", async () => {\n+      const { result } = renderHook(() =>\n+        usePresets({ storage: mockStorage, systemPresets: mockSystemPresets }),\n+      );\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      await expect(\n+        result.current.updatePreset(\"system-1\", { name: \"Cannot Update\" }),\n+      ).rejects.toThrow(/Cannot update system preset/i);\n+    });\n+\n+    it(\"should not update non-existent preset\", async () => {\n+      const { result } = renderHook(() => usePresets({ storage: mockStorage }));\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      await expect(\n+        result.current.updatePreset(\"non-existent\", { name: \"Test\" }),\n+      ).rejects.toThrow(/Preset not found/i);\n+    });\n+  });\n+\n+  describe(\"Delete Presets\", () => {\n+    it(\"should delete user presets\", async () => {\n+      const { result } = renderHook(() => usePresets({ storage: mockStorage }));\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      await act(async () => {\n+        await result.current.deletePresets([\"user-1\"]);\n+      });\n+\n+      expect(mockStorage.save).toHaveBeenCalled();\n+      const savedPresets = (mockStorage.save as any).mock.calls[0][0];\n+      expect(savedPresets).toHaveLength(0);\n+    });\n+\n+    it(\"should not delete system presets\", async () => {\n+      const { result } = renderHook(() =>\n+        usePresets({ storage: mockStorage, systemPresets: mockSystemPresets }),\n+      );\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      await act(async () => {\n+        await result.current.deletePresets([\"system-1\", \"user-1\"]);\n+      });\n+\n+      expect(mockStorage.save).toHaveBeenCalled();\n+      const savedPresets = (mockStorage.save as any).mock.calls[0][0];\n+      expect(savedPresets).toHaveLength(0); // Only user preset deleted\n+    });\n+\n+    it(\"should clear active preset if deleted\", async () => {\n+      const { result } = renderHook(() =>\n+        usePresets({\n+          storage: mockStorage,\n+          onPresetChange: mockOnPresetChange,\n+        }),\n+      );\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      act(() => {\n+        result.current.selectPreset(\"user-1\");\n+      });\n+\n+      await act(async () => {\n+        await result.current.deletePresets([\"user-1\"]);\n+      });\n+\n+      expect(result.current.activePresetId).toBeNull();\n+      expect(mockOnPresetChange).toHaveBeenLastCalledWith(null);\n+    });\n+  });\n+\n+  describe(\"Default Preset\", () => {\n+    it(\"should set a preset as default\", async () => {\n+      const { result } = renderHook(() => usePresets({ storage: mockStorage }));\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      await act(async () => {\n+        await result.current.setDefaultPreset(\"user-1\");\n+      });\n+\n+      expect(mockStorage.save).toHaveBeenCalled();\n+      const savedPresets = (mockStorage.save as any).mock.calls[0][0];\n+      const defaultPreset = savedPresets.find((p: FilterPreset) => p.isDefault);\n+\n+      expect(defaultPreset?.id).toBe(\"user-1\");\n+    });\n+\n+    it(\"should clear default preset when null passed\", async () => {\n+      const userPresetsWithDefault = [\n+        {\n+          ...mockUserPresets[0],\n+          isDefault: true,\n+        },\n+      ];\n+      mockStorage.load = vi.fn().mockResolvedValue(userPresetsWithDefault);\n+\n+      const { result } = renderHook(() => usePresets({ storage: mockStorage }));\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      await act(async () => {\n+        await result.current.setDefaultPreset(null);\n+      });\n+\n+      const savedPresets = (mockStorage.save as any).mock.calls[0][0];\n+      const defaultPreset = savedPresets.find((p: FilterPreset) => p.isDefault);\n+\n+      expect(defaultPreset).toBeUndefined();\n+    });\n+  });\n+\n+  describe(\"Export/Import\", () => {\n+    it(\"should export all presets as JSON\", async () => {\n+      const { result } = renderHook(() =>\n+        usePresets({ storage: mockStorage, systemPresets: mockSystemPresets }),\n+      );\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      const exported = result.current.exportPresets();\n+      const parsed = JSON.parse(exported);\n+\n+      expect(parsed).toHaveProperty(\"version\");\n+      expect(parsed).toHaveProperty(\"presets\");\n+      expect(parsed.presets).toHaveLength(1); // Only user presets exported\n+    });\n+\n+    it(\"should export specific presets\", async () => {\n+      const { result } = renderHook(() => usePresets({ storage: mockStorage }));\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      // Add another preset\n+      await act(async () => {\n+        await result.current.savePreset({ name: \"Another\", filterModel: {} });\n+      });\n+\n+      const exported = result.current.exportPresets([\"user-1\"]);\n+      const parsed = JSON.parse(exported);\n+\n+      expect(parsed.presets).toHaveLength(1);\n+      expect(parsed.presets[0].id).toBe(\"user-1\");\n+    });\n+\n+    it(\"should import presets from JSON\", async () => {\n+      const { result } = renderHook(() => usePresets({ storage: mockStorage }));\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      const importData = JSON.stringify({\n+        version: \"1.0\",\n+        presets: [\n+          {\n+            id: \"imported-1\",\n+            name: \"Imported Preset\",\n+            filterModel: {},\n+            createdAt: \"2023-06-01T00:00:00.000Z\",\n+          },\n+        ],\n+      });\n+\n+      await act(async () => {\n+        await result.current.importPresets(importData);\n+      });\n+\n+      expect(mockStorage.save).toHaveBeenCalled();\n+      const savedPresets = (mockStorage.save as any).mock.calls[0][0];\n+\n+      expect(savedPresets).toHaveLength(2); // Original + imported\n+      const imported = savedPresets.find(\n+        (p: FilterPreset) => p.name === \"Imported Preset\",\n+      );\n+      expect(imported).toBeDefined();\n+      expect(imported.id).not.toBe(\"imported-1\"); // Should generate new ID\n+    });\n+\n+    it(\"should handle invalid import data\", async () => {\n+      const { result } = renderHook(() => usePresets({ storage: mockStorage }));\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      await expect(\n+        result.current.importPresets(\"invalid json\"),\n+      ).rejects.toThrow();\n+\n+      await expect(result.current.importPresets(\"{}\")).rejects.toThrow(\n+        /Invalid preset data/i,\n+      );\n+    });\n+  });\n+\n+  describe(\"Storage Info\", () => {\n+    it(\"should load storage info on mount\", async () => {\n+      const { result } = renderHook(() => usePresets({ storage: mockStorage }));\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      expect(result.current.storageInfo).toEqual({\n+        used: 50,\n+        total: 100,\n+        percentage: 50,\n+      });\n+    });\n+\n+    it(\"should refresh storage info\", async () => {\n+      const { result } = renderHook(() => usePresets({ storage: mockStorage }));\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      mockStorage.getStorageInfo = vi.fn().mockResolvedValue({\n+        used: 75,\n+        total: 100,\n+        percentage: 75,\n+      });\n+\n+      await act(async () => {\n+        await result.current.refreshStorageInfo();\n+      });\n+\n+      expect(result.current.storageInfo).toEqual({\n+        used: 75,\n+        total: 100,\n+        percentage: 75,\n+      });\n+    });\n+\n+    it(\"should handle missing getStorageInfo method\", async () => {\n+      mockStorage.getStorageInfo = undefined;\n+\n+      const { result } = renderHook(() => usePresets({ storage: mockStorage }));\n+\n+      await waitFor(() => {\n+        expect(result.current.isLoading).toBe(false);\n+      });\n+\n+      expect(result.current.storageInfo).toBeNull();\n+    });\n+  });\n+});\ndiff --git a/src/components/FilterPresets/hooks/usePresets.ts b/src/components/FilterPresets/hooks/usePresets.ts\nnew file mode 100644\nindex 0000000..62c1627\n--- /dev/null\n+++ b/src/components/FilterPresets/hooks/usePresets.ts\n@@ -0,0 +1,303 @@\n+import { useState, useEffect, useCallback, useMemo } from \"react\";\n+import type {\n+  FilterPreset,\n+  UsePresetsOptions,\n+  UsePresetsReturn,\n+  StorageInfo,\n+} from \"../types\";\n+\n+function generateId(): string {\n+  return `preset-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n+}\n+\n+export function usePresets({\n+  storage,\n+  systemPresets = [],\n+  onPresetChange,\n+  maxPresets = 50,\n+}: UsePresetsOptions = {}): UsePresetsReturn {\n+  const [userPresets, setUserPresets] = useState<FilterPreset[]>([]);\n+  const [activePresetId, setActivePresetId] = useState<string | null>(null);\n+  const [storageInfo, setStorageInfo] = useState<StorageInfo | null>(null);\n+  const [isLoading, setIsLoading] = useState(false);\n+  const [error, setError] = useState<Error | null>(null);\n+\n+  // Combine system and user presets\n+  const presets = useMemo(() => {\n+    return [...systemPresets, ...userPresets];\n+  }, [systemPresets, userPresets]);\n+\n+  // Load presets from storage\n+  useEffect(() => {\n+    if (!storage) return;\n+\n+    const loadPresets = async () => {\n+      setIsLoading(true);\n+      setError(null);\n+      try {\n+        const loaded = await storage.load();\n+        setUserPresets(loaded);\n+\n+        if (storage.getStorageInfo) {\n+          const info = await storage.getStorageInfo();\n+          setStorageInfo(info);\n+        }\n+      } catch (err) {\n+        setError(\n+          err instanceof Error ? err : new Error(\"Failed to load presets\"),\n+        );\n+        setUserPresets([]);\n+      } finally {\n+        setIsLoading(false);\n+      }\n+    };\n+\n+    loadPresets();\n+  }, [storage]);\n+\n+  // Save user presets to storage\n+  const saveToStorage = useCallback(\n+    async (presets: FilterPreset[]) => {\n+      if (!storage) return;\n+\n+      await storage.save(presets);\n+      setUserPresets(presets);\n+\n+      if (storage.getStorageInfo) {\n+        const info = await storage.getStorageInfo();\n+        setStorageInfo(info);\n+      }\n+    },\n+    [storage],\n+  );\n+\n+  // Select a preset\n+  const selectPreset = useCallback(\n+    (presetId: string | null) => {\n+      if (presetId === null) {\n+        setActivePresetId(null);\n+        onPresetChange?.(null);\n+        return;\n+      }\n+\n+      const preset = presets.find((p) => p.id === presetId);\n+      if (preset) {\n+        setActivePresetId(presetId);\n+        onPresetChange?.(preset);\n+      }\n+    },\n+    [presets, onPresetChange],\n+  );\n+\n+  // Save a new preset\n+  const savePreset = useCallback(\n+    async (preset: Partial<FilterPreset>) => {\n+      if (userPresets.length >= maxPresets) {\n+        throw new Error(\n+          `Cannot save preset: maximum number of presets (${maxPresets}) reached`,\n+        );\n+      }\n+\n+      const now = new Date();\n+      const newPreset: FilterPreset = {\n+        id: generateId(),\n+        name: preset.name || \"Untitled Preset\",\n+        description: preset.description,\n+        tags: preset.tags,\n+        filterModel: preset.filterModel || {},\n+        isDefault: preset.isDefault,\n+        createdAt: now,\n+        updatedAt: now,\n+      };\n+\n+      let updatedPresets = [...userPresets];\n+\n+      // If setting as default, clear other defaults\n+      if (newPreset.isDefault) {\n+        updatedPresets = updatedPresets.map((p) => ({\n+          ...p,\n+          isDefault: false,\n+        }));\n+      }\n+\n+      updatedPresets.push(newPreset);\n+      await saveToStorage(updatedPresets);\n+    },\n+    [userPresets, maxPresets, saveToStorage],\n+  );\n+\n+  // Update an existing preset\n+  const updatePreset = useCallback(\n+    async (id: string, updates: Partial<FilterPreset>) => {\n+      const preset = presets.find((p) => p.id === id);\n+      if (!preset) {\n+        throw new Error(\"Preset not found\");\n+      }\n+      if (preset.isSystem) {\n+        throw new Error(\"Cannot update system presets\");\n+      }\n+\n+      let updatedPresets = userPresets.map((p) => {\n+        if (p.id === id) {\n+          return {\n+            ...p,\n+            ...updates,\n+            id: p.id, // Prevent ID changes\n+            isSystem: false, // Prevent making it system\n+            updatedAt: new Date(),\n+          };\n+        }\n+        return p;\n+      });\n+\n+      // If setting as default, clear other defaults\n+      if (updates.isDefault) {\n+        updatedPresets = updatedPresets.map((p) => ({\n+          ...p,\n+          isDefault: p.id === id,\n+        }));\n+      }\n+\n+      await saveToStorage(updatedPresets);\n+    },\n+    [presets, userPresets, saveToStorage],\n+  );\n+\n+  // Delete presets\n+  const deletePresets = useCallback(\n+    async (ids: string[]) => {\n+      const idsToDelete = new Set(ids);\n+\n+      // Filter out system presets from deletion\n+      const userPresetsToDelete = userPresets\n+        .filter((p) => idsToDelete.has(p.id))\n+        .map((p) => p.id);\n+\n+      if (userPresetsToDelete.length === 0) return;\n+\n+      const updatedPresets = userPresets.filter((p) => !idsToDelete.has(p.id));\n+      await saveToStorage(updatedPresets);\n+\n+      // Clear active preset if it was deleted\n+      if (activePresetId && idsToDelete.has(activePresetId)) {\n+        selectPreset(null);\n+      }\n+    },\n+    [userPresets, activePresetId, selectPreset, saveToStorage],\n+  );\n+\n+  // Set default preset\n+  const setDefaultPreset = useCallback(\n+    async (id: string | null) => {\n+      if (id === null) {\n+        // Clear all defaults\n+        const updatedPresets = userPresets.map((p) => ({\n+          ...p,\n+          isDefault: false,\n+        }));\n+        await saveToStorage(updatedPresets);\n+        return;\n+      }\n+\n+      const preset = presets.find((p) => p.id === id);\n+      if (!preset) {\n+        throw new Error(\"Preset not found\");\n+      }\n+      if (preset.isSystem) {\n+        throw new Error(\"Cannot set system preset as default\");\n+      }\n+\n+      const updatedPresets = userPresets.map((p) => ({\n+        ...p,\n+        isDefault: p.id === id,\n+        updatedAt: p.id === id ? new Date() : p.updatedAt,\n+      }));\n+\n+      await saveToStorage(updatedPresets);\n+    },\n+    [presets, userPresets, saveToStorage],\n+  );\n+\n+  // Export presets\n+  const exportPresets = useCallback(\n+    (ids?: string[]) => {\n+      const presetsToExport = ids\n+        ? userPresets.filter((p) => ids.includes(p.id))\n+        : userPresets;\n+\n+      return JSON.stringify(\n+        {\n+          version: \"1.0\",\n+          exportedAt: new Date().toISOString(),\n+          presets: presetsToExport,\n+        },\n+        null,\n+        2,\n+      );\n+    },\n+    [userPresets],\n+  );\n+\n+  // Import presets\n+  const importPresets = useCallback(\n+    async (data: string) => {\n+      try {\n+        const parsed = JSON.parse(data);\n+\n+        if (!parsed.presets || !Array.isArray(parsed.presets)) {\n+          throw new Error(\"Invalid preset data format\");\n+        }\n+\n+        const importedPresets: FilterPreset[] = parsed.presets.map(\n+          (p: any) => ({\n+            ...p,\n+            id: generateId(), // Generate new IDs to avoid conflicts\n+            createdAt: new Date(p.createdAt || Date.now()),\n+            updatedAt: new Date(p.updatedAt || Date.now()),\n+            isDefault: false, // Don't import default status\n+          }),\n+        );\n+\n+        const newTotal = userPresets.length + importedPresets.length;\n+        if (newTotal > maxPresets) {\n+          throw new Error(\n+            `Cannot import presets: would exceed maximum (${maxPresets})`,\n+          );\n+        }\n+\n+        const updatedPresets = [...userPresets, ...importedPresets];\n+        await saveToStorage(updatedPresets);\n+      } catch (err) {\n+        if (err instanceof SyntaxError) {\n+          throw new Error(\"Invalid JSON format\");\n+        }\n+        throw err;\n+      }\n+    },\n+    [userPresets, maxPresets, saveToStorage],\n+  );\n+\n+  // Refresh storage info\n+  const refreshStorageInfo = useCallback(async () => {\n+    if (!storage?.getStorageInfo) return;\n+\n+    const info = await storage.getStorageInfo();\n+    setStorageInfo(info);\n+  }, [storage]);\n+\n+  return {\n+    presets,\n+    activePresetId,\n+    storageInfo,\n+    isLoading,\n+    error,\n+    selectPreset,\n+    savePreset,\n+    updatePreset,\n+    deletePresets,\n+    setDefaultPreset,\n+    exportPresets,\n+    importPresets,\n+    refreshStorageInfo,\n+  };\n+}\ndiff --git a/src/components/FilterPresets/index.ts b/src/components/FilterPresets/index.ts\nindex e03d3bb..c270d0f 100644\n--- a/src/components/FilterPresets/index.ts\n+++ b/src/components/FilterPresets/index.ts\n@@ -1,5 +1,5 @@\n export * from \"./types\";\n export { PresetSelector } from \"./PresetSelector\";\n export { SavePresetDialog } from \"./SavePresetDialog\";\n-export { PresetManager } from \"./PresetManager\";\n+// export { PresetManager } from \"./PresetManager\"; // TODO: uncomment when implemented\n export { usePresets } from \"./hooks/usePresets\";\ndiff --git a/src/components/FilterPresets/types.ts b/src/components/FilterPresets/types.ts\nindex 762d608..59cbd07 100644\n--- a/src/components/FilterPresets/types.ts\n+++ b/src/components/FilterPresets/types.ts\n@@ -1,5 +1,7 @@\n import type { ReactNode } from \"react\";\n-import type { FilterModelV33 } from \"../interfaces\";\n+\n+// Type for AG Grid v33+ filter models\n+export type FilterModelV33 = Record<string, any>;\n \n export interface FilterPreset {\n   id: string;\n",
  "context": {
    "issue": 48,
    "branch": "feature/48-create-ui-components-for-filter-preset-management",
    "worktree": "/Users/ryan/ag-grid-worktrees/feature/48-create-ui-components-for-filter-preset-management",
    "createdAt": "2025-07-06T14:15:36.623Z",
    "status": "initialized",
    "lastCheckpoint": "2025-07-06T16:02:43.537Z",
    "checkpointMessage": "Implemented PresetManager component with all tests passing",
    "checkpoints": 5
  }
}
