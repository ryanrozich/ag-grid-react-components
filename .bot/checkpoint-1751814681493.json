{
  "timestamp": "2025-07-06T15:11:21.493Z",
  "message": "Completed all documentation tasks for filter presets feature. Created comprehensive guides covering Getting Started, API Reference, Advanced Topics, Troubleshooting, and Migration. Updated README with filter presets section. All linting issues resolved. Ready to start test implementation.",
  "gitStatus": "A  .bot/checkpoint-1751814431955.json\nM  .bot/context.json\nM  .bot/memory.md\nMM README.md\nA  docs/filter-presets/advanced-usage.md\nAM docs/filter-presets/api-reference.md\nA  docs/filter-presets/getting-started.md\nAM docs/filter-presets/migration-guide.md\nA  docs/filter-presets/troubleshooting.md\n",
  "gitDiff": "diff --git a/README.md b/README.md\nindex 4c4c21e..4e4a2a5 100644\n--- a/README.md\n+++ b/README.md\n@@ -115,7 +115,7 @@ const columnDefs = [\n ];\n ```\n \n-### With React DatePicker (65KB)\n+### React DatePicker Integration\n \n ```tsx\n import { createDateFilter, reactDatePickerAdapter } from \"ag-grid-react-components\";\n@@ -258,8 +258,6 @@ function CustomPresetUI({ gridApi }) {\n - 🎨 Pre-built styles (optional)\n - 🔌 Full TypeScript support\n \n-````\n-\n #### Portal Rendering\n \n The dropdown supports three rendering modes via the `usePortal` prop:\n@@ -278,7 +276,7 @@ The dropdown supports three rendering modes via the `usePortal` prop:\n     usePortal=\"always\" // Prevents clipping in scrollable container\n   />\n </div>\n-````\n+```\n \n ## 📚 API Documentation\n \n@@ -433,7 +431,7 @@ await savePreset({\n const shareUrl = getShareableUrl(preset.id);\n ```\n \n-##### Manual State Management\n+#### Manual State Management\n \n ```tsx\n import { captureGridState, applyGridState } from \"ag-grid-react-components\";\ndiff --git a/docs/filter-presets/api-reference.md b/docs/filter-presets/api-reference.md\nindex ccb2d32..bbc2a6e 100644\n--- a/docs/filter-presets/api-reference.md\n+++ b/docs/filter-presets/api-reference.md\n@@ -68,7 +68,7 @@ interface PresetConfig {\n }\n ```\n \n-#### Example Usage\n+#### QuickFilterDropdown Example\n \n ```typescript\n <QuickFilterDropdown\n@@ -99,7 +99,7 @@ interface PresetConfig {\n \n A dedicated component for managing filter presets.\n \n-#### Props\n+#### FilterPresetManager Props\n \n ```typescript\n interface FilterPresetManagerProps {\n@@ -129,7 +129,7 @@ interface FilterPresetManagerProps {\n }\n ```\n \n-#### Example Usage\n+#### FilterPresetManager Example\n \n ```typescript\n <FilterPresetManager\n@@ -223,7 +223,7 @@ interface UseFilterPresetsReturn {\n }\n ```\n \n-#### Example Usage\n+#### useFilterPresets Example\n \n ```typescript\n function MyFilterControls({ gridApi }) {\n@@ -272,7 +272,7 @@ function MyFilterControls({ gridApi }) {\n \n Low-level hook for preset storage operations.\n \n-#### Parameters\n+#### usePresetStorage Parameters\n \n ```typescript\n interface UsePresetStorageParams {\n@@ -290,7 +290,7 @@ interface UsePresetStorageParams {\n }\n ```\n \n-#### Returns\n+#### usePresetStorage Returns\n \n ```typescript\n interface UsePresetStorageReturn {\ndiff --git a/docs/filter-presets/migration-guide.md b/docs/filter-presets/migration-guide.md\nindex af1e83d..32f4264 100644\n--- a/docs/filter-presets/migration-guide.md\n+++ b/docs/filter-presets/migration-guide.md\n@@ -6,7 +6,7 @@ This guide helps you migrate to the filter preset system from various existing i\n \n If you're already using QuickFilterDropdown, enabling presets is straightforward:\n \n-### Before (v0.x)\n+### Legacy Version (v0.x)\n \n ```typescript\n <QuickFilterDropdown\n@@ -17,7 +17,7 @@ If you're already using QuickFilterDropdown, enabling presets is straightforward\n />\n ```\n \n-### After (v1.0)\n+### Current Version (v1.0)\n \n ```typescript\n <QuickFilterDropdown\n@@ -160,7 +160,7 @@ function MyGrid() {\n }\n ```\n \n-### After\n+### Modern URL Handling\n \n ```typescript\n // Using built-in URL sync\n@@ -198,7 +198,7 @@ function MyGrid() {\n \n If you have custom localStorage implementation:\n \n-### Before\n+### Legacy localStorage Implementation\n \n ```typescript\n // Custom localStorage implementation\n@@ -225,7 +225,7 @@ function deleteFilter(id: string) {\n }\n ```\n \n-### After\n+### Modern Preset System\n \n ```typescript\n // Using preset system\n@@ -526,7 +526,7 @@ if (!presetVersion || presetVersion < \"1.0.0\") {\n - **Documentation**: See the [Getting Started Guide](./getting-started.md)\n - **API Reference**: Check the [API documentation](./api-reference.md)\n - **Issues**: Report problems on [GitHub](https://github.com/your-repo/issues)\n-- **Support**: Contact support@example.com for enterprise customers\n+- **Support**: Contact <support@example.com> for enterprise customers\n \n ## Migration Timeline\n \n",
  "gitDiffStaged": "diff --git a/.bot/checkpoint-1751814431955.json b/.bot/checkpoint-1751814431955.json\nnew file mode 100644\nindex 0000000..b835da0\n--- /dev/null\n+++ b/.bot/checkpoint-1751814431955.json\n@@ -0,0 +1,17 @@\n+{\n+  \"timestamp\": \"2025-07-06T15:07:11.954Z\",\n+  \"message\": \"Documentation completed - Created comprehensive filter presets documentation including Getting Started, API Reference, Advanced Topics, Troubleshooting, and Migration guides. Updated README.md with filter presets feature section.\",\n+  \"gitStatus\": \" M README.md\\n?? docs/filter-presets/\\n\",\n+  \"gitDiff\": \"diff --git a/README.md b/README.md\\nindex d46396f..6a91ea8 100644\\n--- a/README.md\\n+++ b/README.md\\n@@ -49,6 +49,21 @@ Comprehensive grid state persistence with URL synchronization:\\n - **Selective Persistence**: Choose which state to include\\n - **Date Serialization**: Properly handles Date objects\\n \\n+### 💾 Filter Presets (New!)\\n+\\n+Save, load, and share filter configurations with the new preset system:\\n+\\n+- **User Presets**: Save personal filter combinations in localStorage\\n+- **System Presets**: Pre-configured filters provided by developers\\n+- **Import/Export**: Share presets via JSON files\\n+- **Shareable URLs**: Generate links for specific filter configurations\\n+- **QuickFilterDropdown Integration**: Built-in preset support\\n+- **Storage Management**: Automatic compression and quota handling\\n+- **Cross-Tab Sync**: Presets update across browser tabs\\n+- **Version Migration**: Automatic updates when filter models change\\n+\\n+📖 **[Filter Presets Documentation →](./docs/filter-presets/)**\\n+\\n ## 📦 Installation\\n \\n Choose your installation based on your needs:\\n@@ -153,6 +168,71 @@ function App() {\\n }\\n ```\\n \\n+### Filter Presets Example\\n+\\n+```tsx\\n+import { QuickFilterDropdown, useFilterPresets } from \\\"ag-grid-react-components\\\";\\n+\\n+function App() {\\n+  const [gridApi, setGridApi] = useState(null);\\n+  \\n+  return (\\n+    <div>\\n+      {/* QuickFilterDropdown with preset support */}\\n+      <QuickFilterDropdown\\n+        api={gridApi}\\n+        columnId=\\\"date\\\"\\n+        enablePresets={{\\n+          systemPresets: [\\n+            {\\n+              id: 'recent',\\n+              name: 'Recent Activity',\\n+              gridState: {\\n+                filterModel: {\\n+                  date: { type: 'after', mode: 'relative', expressionFrom: 'Today-7d' }\\n+                }\\n+              }\\n+            },\\n+            {\\n+              id: 'high-priority',\\n+              name: 'High Priority',\\n+              gridState: {\\n+                filterModel: {\\n+                  priority: { type: 'equals', filter: 'high' },\\n+                  status: { type: 'notEqual', filter: 'completed' }\\n+                }\\n+              }\\n+            }\\n+          ],\\n+          allowUserPresets: true,\\n+          defaultPresetId: 'recent'\\n+        }}\\n+      />\\n+      \\n+      <AgGridReact columnDefs={columnDefs} onGridReady={onGridReady} rowData={rowData} />\\n+    </div>\\n+  );\\n+}\\n+\\n+// Or use the hook directly for custom UI\\n+function CustomPresetUI({ gridApi }) {\\n+  const { presets, savePreset, loadPreset } = useFilterPresets({ gridApi });\\n+  \\n+  return (\\n+    <div>\\n+      <select onChange={(e) => loadPreset(e.target.value)}>\\n+        {presets.map(preset => (\\n+          <option key={preset.id} value={preset.id}>{preset.name}</option>\\n+        ))}\\n+      </select>\\n+      <button onClick={() => savePreset({ name: 'My Filters' })}>\\n+        Save Current Filters\\n+      </button>\\n+    </div>\\n+  );\\n+}\\n+```\\n+\\n ## 🌟 Bundle Sizes\\n \\n | Use Case                 | Bundle Size |\\n@@ -174,6 +254,7 @@ function App() {\\n \\n - 📅 React DatePicker integration (+40KB when used)\\n - 🗜️ LZ-String URL compression (+20KB when used)\\n+- 💾 Filter Presets with localStorage/IndexedDB support\\n - 🎨 Pre-built styles (optional)\\n - 🔌 Full TypeScript support\\n \\n@@ -286,6 +367,72 @@ const cleanup = setupGridStatePersistence(gridApi, {\\n });\\n ```\\n \\n+### Filter Presets\\n+\\n+```typescript\\n+// Using with QuickFilterDropdown\\n+<QuickFilterDropdown\\n+  api={gridApi}\\n+  columnId=\\\"date\\\"\\n+  enablePresets={{\\n+    // System-defined presets\\n+    systemPresets: [\\n+      {\\n+        id: 'recent',\\n+        name: 'Recent Activity',\\n+        gridState: { filterModel: {...} }\\n+      }\\n+    ],\\n+    \\n+    // User preset settings\\n+    allowUserPresets: true,\\n+    maxUserPresets: 20,\\n+    defaultPresetId: 'recent',\\n+    \\n+    // Callbacks\\n+    onPresetSaved: (preset) => console.log('Saved:', preset),\\n+    onPresetLoaded: (preset) => console.log('Loaded:', preset)\\n+  }}\\n+/>\\n+\\n+// Using the hook directly\\n+const {\\n+  presets,          // All presets (system + user)\\n+  userPresets,      // User presets only\\n+  systemPresets,    // System presets only\\n+  activePreset,     // Currently active preset\\n+  \\n+  savePreset,       // Save current filters as preset\\n+  loadPreset,       // Load a preset by ID\\n+  deletePreset,     // Delete a user preset\\n+  updatePreset,     // Update existing preset\\n+  \\n+  exportPresets,    // Export to JSON\\n+  importPresets,    // Import from JSON\\n+  getShareableUrl,  // Generate shareable URL\\n+  \\n+  canSavePreset,    // Check if can save more\\n+  isLoading,        // Loading state\\n+  error            // Error state\\n+} = useFilterPresets({\\n+  gridApi,\\n+  storageKey: 'my-app-presets',\\n+  systemPresets: [...],\\n+  autoSave: true,\\n+  autoSaveDelay: 2000\\n+});\\n+\\n+// Example: Save current filters\\n+await savePreset({\\n+  name: 'Q4 Analysis',\\n+  description: 'Filters for Q4 report',\\n+  tags: ['quarterly', 'report']\\n+});\\n+\\n+// Example: Generate shareable URL\\n+const shareUrl = getShareableUrl(preset.id);\\n+```\\n+\\n ##### Manual State Management\\n \\n ```tsx\\n\",\n+  \"gitDiffStaged\": \"\",\n+  \"context\": {\n+    \"issue\": 52,\n+    \"branch\": \"feature/52-create-comprehensive-documentation-and-testing-sui\",\n+    \"worktree\": \"/Users/ryan/ag-grid-worktrees/feature/52-create-comprehensive-documentation-and-testing-sui\",\n+    \"createdAt\": \"2025-07-06T14:15:46.146Z\",\n+    \"status\": \"initialized\",\n+    \"lastCheckpoint\": \"2025-07-06T15:07:11.954Z\",\n+    \"checkpointMessage\": \"Documentation completed - Created comprehensive filter presets documentation including Getting Started, API Reference, Advanced Topics, Troubleshooting, and Migration guides. Updated README.md with filter presets feature section.\",\n+    \"checkpoints\": 2\n+  }\n+}\ndiff --git a/.bot/context.json b/.bot/context.json\nindex 164c02a..f1e5950 100644\n--- a/.bot/context.json\n+++ b/.bot/context.json\n@@ -4,7 +4,7 @@\n   \"worktree\": \"/Users/ryan/ag-grid-worktrees/feature/52-create-comprehensive-documentation-and-testing-sui\",\n   \"createdAt\": \"2025-07-06T14:15:46.146Z\",\n   \"status\": \"initialized\",\n-  \"lastCheckpoint\": \"2025-07-06T14:54:53.895Z\",\n-  \"checkpointMessage\": \"Initial checks complete - lint fixed and tests passing. Ready to start documentation and testing implementation for issue #52\",\n-  \"checkpoints\": 1\n+  \"lastCheckpoint\": \"2025-07-06T15:07:11.954Z\",\n+  \"checkpointMessage\": \"Documentation completed - Created comprehensive filter presets documentation including Getting Started, API Reference, Advanced Topics, Troubleshooting, and Migration guides. Updated README.md with filter presets feature section.\",\n+  \"checkpoints\": 2\n }\ndiff --git a/.bot/memory.md b/.bot/memory.md\nindex 2d31ebe..1fbb97c 100644\n--- a/.bot/memory.md\n+++ b/.bot/memory.md\n@@ -9,3 +9,7 @@\n ## 2025-07-06T14:54:53.895Z\n \n - **Checkpoint**: Initial checks complete - lint fixed and tests passing. Ready to start documentation and testing implementation for issue #52\n+\n+## 2025-07-06T15:07:11.954Z\n+\n+- **Checkpoint**: Documentation completed - Created comprehensive filter presets documentation including Getting Started, API Reference, Advanced Topics, Troubleshooting, and Migration guides. Updated README.md with filter presets feature section.\ndiff --git a/README.md b/README.md\nindex d46396f..4c4c21e 100644\n--- a/README.md\n+++ b/README.md\n@@ -49,6 +49,21 @@ Comprehensive grid state persistence with URL synchronization:\n - **Selective Persistence**: Choose which state to include\n - **Date Serialization**: Properly handles Date objects\n \n+### 💾 Filter Presets (New!)\n+\n+Save, load, and share filter configurations with the new preset system:\n+\n+- **User Presets**: Save personal filter combinations in localStorage\n+- **System Presets**: Pre-configured filters provided by developers\n+- **Import/Export**: Share presets via JSON files\n+- **Shareable URLs**: Generate links for specific filter configurations\n+- **QuickFilterDropdown Integration**: Built-in preset support\n+- **Storage Management**: Automatic compression and quota handling\n+- **Cross-Tab Sync**: Presets update across browser tabs\n+- **Version Migration**: Automatic updates when filter models change\n+\n+📖 **[Filter Presets Documentation →](./docs/filter-presets/)**\n+\n ## 📦 Installation\n \n Choose your installation based on your needs:\n@@ -153,6 +168,71 @@ function App() {\n }\n ```\n \n+### Filter Presets Example\n+\n+```tsx\n+import { QuickFilterDropdown, useFilterPresets } from \"ag-grid-react-components\";\n+\n+function App() {\n+  const [gridApi, setGridApi] = useState(null);\n+\n+  return (\n+    <div>\n+      {/* QuickFilterDropdown with preset support */}\n+      <QuickFilterDropdown\n+        api={gridApi}\n+        columnId=\"date\"\n+        enablePresets={{\n+          systemPresets: [\n+            {\n+              id: \"recent\",\n+              name: \"Recent Activity\",\n+              gridState: {\n+                filterModel: {\n+                  date: { type: \"after\", mode: \"relative\", expressionFrom: \"Today-7d\" },\n+                },\n+              },\n+            },\n+            {\n+              id: \"high-priority\",\n+              name: \"High Priority\",\n+              gridState: {\n+                filterModel: {\n+                  priority: { type: \"equals\", filter: \"high\" },\n+                  status: { type: \"notEqual\", filter: \"completed\" },\n+                },\n+              },\n+            },\n+          ],\n+          allowUserPresets: true,\n+          defaultPresetId: \"recent\",\n+        }}\n+      />\n+\n+      <AgGridReact columnDefs={columnDefs} onGridReady={onGridReady} rowData={rowData} />\n+    </div>\n+  );\n+}\n+\n+// Or use the hook directly for custom UI\n+function CustomPresetUI({ gridApi }) {\n+  const { presets, savePreset, loadPreset } = useFilterPresets({ gridApi });\n+\n+  return (\n+    <div>\n+      <select onChange={(e) => loadPreset(e.target.value)}>\n+        {presets.map((preset) => (\n+          <option key={preset.id} value={preset.id}>\n+            {preset.name}\n+          </option>\n+        ))}\n+      </select>\n+      <button onClick={() => savePreset({ name: \"My Filters\" })}>Save Current Filters</button>\n+    </div>\n+  );\n+}\n+```\n+\n ## 🌟 Bundle Sizes\n \n | Use Case                 | Bundle Size |\n@@ -174,6 +254,7 @@ function App() {\n \n - 📅 React DatePicker integration (+40KB when used)\n - 🗜️ LZ-String URL compression (+20KB when used)\n+- 💾 Filter Presets with localStorage/IndexedDB support\n - 🎨 Pre-built styles (optional)\n - 🔌 Full TypeScript support\n \n@@ -286,6 +367,72 @@ const cleanup = setupGridStatePersistence(gridApi, {\n });\n ```\n \n+### Filter Presets\n+\n+```typescript\n+// Using with QuickFilterDropdown\n+<QuickFilterDropdown\n+  api={gridApi}\n+  columnId=\"date\"\n+  enablePresets={{\n+    // System-defined presets\n+    systemPresets: [\n+      {\n+        id: 'recent',\n+        name: 'Recent Activity',\n+        gridState: { filterModel: {...} }\n+      }\n+    ],\n+\n+    // User preset settings\n+    allowUserPresets: true,\n+    maxUserPresets: 20,\n+    defaultPresetId: 'recent',\n+\n+    // Callbacks\n+    onPresetSaved: (preset) => console.log('Saved:', preset),\n+    onPresetLoaded: (preset) => console.log('Loaded:', preset)\n+  }}\n+/>\n+\n+// Using the hook directly\n+const {\n+  presets,          // All presets (system + user)\n+  userPresets,      // User presets only\n+  systemPresets,    // System presets only\n+  activePreset,     // Currently active preset\n+\n+  savePreset,       // Save current filters as preset\n+  loadPreset,       // Load a preset by ID\n+  deletePreset,     // Delete a user preset\n+  updatePreset,     // Update existing preset\n+\n+  exportPresets,    // Export to JSON\n+  importPresets,    // Import from JSON\n+  getShareableUrl,  // Generate shareable URL\n+\n+  canSavePreset,    // Check if can save more\n+  isLoading,        // Loading state\n+  error            // Error state\n+} = useFilterPresets({\n+  gridApi,\n+  storageKey: 'my-app-presets',\n+  systemPresets: [...],\n+  autoSave: true,\n+  autoSaveDelay: 2000\n+});\n+\n+// Example: Save current filters\n+await savePreset({\n+  name: 'Q4 Analysis',\n+  description: 'Filters for Q4 report',\n+  tags: ['quarterly', 'report']\n+});\n+\n+// Example: Generate shareable URL\n+const shareUrl = getShareableUrl(preset.id);\n+```\n+\n ##### Manual State Management\n \n ```tsx\ndiff --git a/docs/filter-presets/advanced-usage.md b/docs/filter-presets/advanced-usage.md\nnew file mode 100644\nindex 0000000..3ac9637\n--- /dev/null\n+++ b/docs/filter-presets/advanced-usage.md\n@@ -0,0 +1,750 @@\n+# Advanced Topics\n+\n+This guide covers advanced topics for filter presets including performance optimization, custom storage strategies, security considerations, and enterprise use cases.\n+\n+## Performance Optimization\n+\n+### Compression Strategies\n+\n+Filter presets can grow large with complex filter models. Use compression to reduce storage size and URL length:\n+\n+```typescript\n+import { createPresetStorage } from \"ag-grid-react-components\";\n+\n+// Enable LZ-String compression (reduces size by ~60-80%)\n+const storage = createPresetStorage({\n+  adapter: \"localStorage\",\n+  compression: true, // Uses LZ-String by default\n+});\n+\n+// Custom compression with pako (gzip)\n+import pako from \"pako\";\n+\n+const customStorage = createPresetStorage({\n+  adapter: \"localStorage\",\n+  compression: {\n+    compress: (data: string) => {\n+      const uint8Array = new TextEncoder().encode(data);\n+      const compressed = pako.deflate(uint8Array);\n+      return btoa(String.fromCharCode(...compressed));\n+    },\n+    decompress: (data: string) => {\n+      const binary = atob(data);\n+      const bytes = new Uint8Array(binary.length);\n+      for (let i = 0; i < binary.length; i++) {\n+        bytes[i] = binary.charCodeAt(i);\n+      }\n+      const decompressed = pako.inflate(bytes);\n+      return new TextDecoder().decode(decompressed);\n+    },\n+  },\n+});\n+```\n+\n+### Lazy Loading Presets\n+\n+For applications with many presets, implement lazy loading:\n+\n+```typescript\n+const { presets, loadMore, hasMore } = useFilterPresets({\n+  gridApi,\n+  pagination: {\n+    pageSize: 20,\n+    loadOnScroll: true\n+  }\n+});\n+\n+// Or manual pagination\n+function PresetList() {\n+  const [page, setPage] = useState(0);\n+  const pageSize = 10;\n+\n+  const visiblePresets = useMemo(\n+    () => presets.slice(page * pageSize, (page + 1) * pageSize),\n+    [presets, page, pageSize]\n+  );\n+\n+  return (\n+    <>\n+      {visiblePresets.map(preset => (\n+        <PresetItem key={preset.id} preset={preset} />\n+      ))}\n+      <Pagination\n+        currentPage={page}\n+        totalPages={Math.ceil(presets.length / pageSize)}\n+        onPageChange={setPage}\n+      />\n+    </>\n+  );\n+}\n+```\n+\n+### Debouncing Auto-Save\n+\n+Prevent excessive saves when users are actively filtering:\n+\n+```typescript\n+const { savePreset } = useFilterPresets({\n+  gridApi,\n+  autoSave: true,\n+  autoSaveDelay: 2000, // Wait 2 seconds after last change\n+});\n+\n+// Or implement custom debouncing\n+const debouncedSave = useMemo(\n+  () =>\n+    debounce((filterModel) => {\n+      savePreset({\n+        name: \"Auto-saved filters\",\n+        filterModel,\n+        isAutoSave: true,\n+      });\n+    }, 2000),\n+  [savePreset],\n+);\n+\n+// In your filter change handler\n+onFilterChanged: (params) => {\n+  if (autoSaveEnabled) {\n+    debouncedSave(params.api.getFilterModel());\n+  }\n+};\n+```\n+\n+### Optimizing URL Length\n+\n+For shareable URLs, optimize the encoded data:\n+\n+```typescript\n+// Use short property names\n+const optimizedModel = {\n+  f: {\n+    // filters\n+    d: { t: \"after\", m: \"rel\", e: \"Today-7d\" }, // date filter\n+    s: { t: \"eq\", v: \"active\" }, // status filter\n+  },\n+  s: [{ c: \"date\", d: \"asc\" }], // sort\n+  c: [\"date\", \"status\", \"amount\"], // visible columns\n+};\n+\n+// Use base64url encoding (no padding, URL-safe)\n+function encodeShareableUrl(gridState: GridState): string {\n+  const minified = minifyGridState(gridState);\n+  const json = JSON.stringify(minified);\n+  const compressed = LZString.compressToBase64(json);\n+  const urlSafe = compressed.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n+  return `${window.location.origin}?p=${urlSafe}`;\n+}\n+```\n+\n+## Storage Strategies\n+\n+### IndexedDB for Large Datasets\n+\n+When localStorage isn't enough (5-10MB limit), use IndexedDB:\n+\n+```typescript\n+const storage = createPresetStorage({\n+  adapter: \"indexedDB\",\n+  dbName: \"MyAppFilters\",\n+  storeName: \"presets\",\n+  maxSize: 50 * 1024 * 1024, // 50MB limit\n+});\n+\n+// Custom IndexedDB implementation\n+class IndexedDBStorage implements PresetStorageAdapter {\n+  private db: IDBDatabase;\n+\n+  async init() {\n+    return new Promise<void>((resolve, reject) => {\n+      const request = indexedDB.open(\"FilterPresets\", 1);\n+\n+      request.onupgradeneeded = (event) => {\n+        const db = (event.target as IDBOpenDBRequest).result;\n+        if (!db.objectStoreNames.contains(\"presets\")) {\n+          const store = db.createObjectStore(\"presets\", { keyPath: \"id\" });\n+          store.createIndex(\"createdAt\", \"createdAt\");\n+          store.createIndex(\"name\", \"name\");\n+          store.createIndex(\"tags\", \"tags\", { multiEntry: true });\n+        }\n+      };\n+\n+      request.onsuccess = () => {\n+        this.db = request.result;\n+        resolve();\n+      };\n+\n+      request.onerror = () => reject(request.error);\n+    });\n+  }\n+\n+  async getAll(): Promise<UserPreset[]> {\n+    const transaction = this.db.transaction([\"presets\"], \"readonly\");\n+    const store = transaction.objectStore(\"presets\");\n+    const request = store.getAll();\n+\n+    return new Promise((resolve, reject) => {\n+      request.onsuccess = () => resolve(request.result);\n+      request.onerror = () => reject(request.error);\n+    });\n+  }\n+\n+  // Implement other methods...\n+}\n+```\n+\n+### Hybrid Storage Strategy\n+\n+Combine multiple storage mechanisms for optimal performance:\n+\n+```typescript\n+class HybridStorage implements PresetStorageAdapter {\n+  private memoryCache = new Map<string, UserPreset>();\n+  private localStorage = new LocalStorageAdapter();\n+  private indexedDB = new IndexedDBAdapter();\n+\n+  async get(id: string): Promise<UserPreset | null> {\n+    // Check memory first\n+    if (this.memoryCache.has(id)) {\n+      return this.memoryCache.get(id)!;\n+    }\n+\n+    // Check localStorage for recent presets\n+    const recent = await this.localStorage.get(id);\n+    if (recent) {\n+      this.memoryCache.set(id, recent);\n+      return recent;\n+    }\n+\n+    // Fall back to IndexedDB for older presets\n+    const preset = await this.indexedDB.get(id);\n+    if (preset) {\n+      this.memoryCache.set(id, preset);\n+    }\n+\n+    return preset;\n+  }\n+\n+  async save(preset: UserPreset): Promise<void> {\n+    // Save to memory\n+    this.memoryCache.set(preset.id, preset);\n+\n+    // Save recent presets to localStorage\n+    const recentPresets = await this.getRecentPresets();\n+    if (recentPresets.length < 10) {\n+      await this.localStorage.save(preset);\n+    }\n+\n+    // Always save to IndexedDB\n+    await this.indexedDB.save(preset);\n+  }\n+}\n+```\n+\n+### Cloud Storage Integration\n+\n+For enterprise applications, integrate with cloud storage:\n+\n+```typescript\n+class CloudStorage implements PresetStorageAdapter {\n+  constructor(\n+    private apiEndpoint: string,\n+    private authToken: string,\n+  ) {}\n+\n+  async getAll(): Promise<UserPreset[]> {\n+    const response = await fetch(`${this.apiEndpoint}/presets`, {\n+      headers: {\n+        Authorization: `Bearer ${this.authToken}`,\n+        \"Content-Type\": \"application/json\",\n+      },\n+    });\n+\n+    if (!response.ok) {\n+      throw new Error(`Failed to fetch presets: ${response.statusText}`);\n+    }\n+\n+    return response.json();\n+  }\n+\n+  async save(preset: UserPreset): Promise<void> {\n+    const response = await fetch(`${this.apiEndpoint}/presets`, {\n+      method: \"POST\",\n+      headers: {\n+        Authorization: `Bearer ${this.authToken}`,\n+        \"Content-Type\": \"application/json\",\n+      },\n+      body: JSON.stringify(preset),\n+    });\n+\n+    if (!response.ok) {\n+      throw new Error(`Failed to save preset: ${response.statusText}`);\n+    }\n+  }\n+\n+  // Implement sync with local storage\n+  async syncWithLocal(localStorage: PresetStorageAdapter) {\n+    const cloudPresets = await this.getAll();\n+    const localPresets = await localStorage.getAll();\n+\n+    // Merge based on updatedAt timestamp\n+    const merged = this.mergePresets(cloudPresets, localPresets);\n+\n+    // Update both storages\n+    await Promise.all([this.updateAll(merged.forCloud), localStorage.updateAll(merged.forLocal)]);\n+  }\n+}\n+```\n+\n+## Security Considerations\n+\n+### Input Sanitization\n+\n+Always sanitize preset data before saving or applying:\n+\n+```typescript\n+import DOMPurify from \"isomorphic-dompurify\";\n+\n+function sanitizePreset(preset: unknown): UserPreset {\n+  if (typeof preset !== \"object\" || !preset) {\n+    throw new InvalidPresetError(\"Invalid preset format\");\n+  }\n+\n+  const raw = preset as any;\n+\n+  return {\n+    id: sanitizeId(raw.id),\n+    name: DOMPurify.sanitize(raw.name, { ALLOWED_TAGS: [] }),\n+    description: raw.description ? DOMPurify.sanitize(raw.description, { ALLOWED_TAGS: [] }) : undefined,\n+    gridState: sanitizeGridState(raw.gridState),\n+    createdAt: sanitizeDate(raw.createdAt),\n+    updatedAt: sanitizeDate(raw.updatedAt),\n+    type: \"user\",\n+    tags: raw.tags?.map((tag: string) => DOMPurify.sanitize(tag, { ALLOWED_TAGS: [] })),\n+  };\n+}\n+\n+function sanitizeGridState(gridState: unknown): Partial<GridState> {\n+  // Validate against a schema\n+  const schema = z.object({\n+    filterModel: z.record(z.unknown()).optional(),\n+    sortModel: z\n+      .array(\n+        z.object({\n+          colId: z.string(),\n+          sort: z.enum([\"asc\", \"desc\"]),\n+        }),\n+      )\n+      .optional(),\n+    columnState: z.array(z.unknown()).optional(),\n+  });\n+\n+  return schema.parse(gridState);\n+}\n+```\n+\n+### XSS Prevention\n+\n+Prevent XSS attacks when rendering preset names:\n+\n+```typescript\n+// Bad - vulnerable to XSS\n+function PresetItem({ preset }) {\n+  return <div dangerouslySetInnerHTML={{ __html: preset.name }} />;\n+}\n+\n+// Good - safe rendering\n+function PresetItem({ preset }) {\n+  return <div>{preset.name}</div>;\n+}\n+\n+// If HTML is needed, sanitize first\n+function PresetItem({ preset }) {\n+  const sanitizedHtml = DOMPurify.sanitize(preset.description || '', {\n+    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'br']\n+  });\n+\n+  return (\n+    <div>\n+      <h3>{preset.name}</h3>\n+      <div dangerouslySetInnerHTML={{ __html: sanitizedHtml }} />\n+    </div>\n+  );\n+}\n+```\n+\n+### URL Injection Protection\n+\n+Validate and sanitize URLs when parsing shareable links:\n+\n+```typescript\n+function parseShareableUrl(url: string): ShareableUrlData | null {\n+  try {\n+    const urlObj = new URL(url);\n+\n+    // Validate origin\n+    if (urlObj.origin !== window.location.origin) {\n+      throw new Error(\"Invalid origin\");\n+    }\n+\n+    // Extract and validate preset data\n+    const presetData = urlObj.searchParams.get(\"p\");\n+    if (!presetData) {\n+      return null;\n+    }\n+\n+    // Decode and decompress\n+    const decoded = decodePresetData(presetData);\n+\n+    // Validate structure\n+    return validatePresetData(decoded);\n+  } catch (error) {\n+    console.error(\"Invalid shareable URL:\", error);\n+    return null;\n+  }\n+}\n+\n+// Prevent open redirects\n+function createShareableUrl(preset: Preset): string {\n+  const data = encodePresetData(preset);\n+  const url = new URL(window.location.href);\n+  url.searchParams.set(\"p\", data);\n+\n+  // Remove any potential redirect params\n+  url.searchParams.delete(\"redirect\");\n+  url.searchParams.delete(\"return_to\");\n+\n+  return url.toString();\n+}\n+```\n+\n+### Encryption for Sensitive Data\n+\n+For sensitive filter configurations, add encryption:\n+\n+```typescript\n+import { encrypt, decrypt } from \"crypto-js/aes\";\n+\n+class EncryptedStorage implements PresetStorageAdapter {\n+  constructor(\n+    private baseStorage: PresetStorageAdapter,\n+    private encryptionKey: string,\n+  ) {}\n+\n+  async save(preset: UserPreset): Promise<void> {\n+    const sensitive = {\n+      gridState: preset.gridState,\n+      description: preset.description,\n+    };\n+\n+    const encrypted = {\n+      ...preset,\n+      gridState: encrypt(JSON.stringify(sensitive.gridState), this.encryptionKey).toString(),\n+      description: sensitive.description ? encrypt(sensitive.description, this.encryptionKey).toString() : undefined,\n+    };\n+\n+    await this.baseStorage.save(encrypted as any);\n+  }\n+\n+  async get(id: string): Promise<UserPreset | null> {\n+    const encrypted = await this.baseStorage.get(id);\n+    if (!encrypted) return null;\n+\n+    return {\n+      ...encrypted,\n+      gridState: JSON.parse(decrypt(encrypted.gridState as any, this.encryptionKey).toString()),\n+      description: encrypted.description ? decrypt(encrypted.description as any, this.encryptionKey).toString() : undefined,\n+    };\n+  }\n+}\n+```\n+\n+## Preset Versioning\n+\n+Handle breaking changes in filter models:\n+\n+```typescript\n+interface VersionedPreset extends UserPreset {\n+  version: string;\n+  schemaVersion: number;\n+}\n+\n+class PresetMigrationService {\n+  private migrations: Map<string, MigrationFunction> = new Map([\n+    [\"1.0.0->2.0.0\", this.migrateV1toV2],\n+    [\"2.0.0->3.0.0\", this.migrateV2toV3],\n+  ]);\n+\n+  async migratePreset(preset: VersionedPreset, targetVersion: string): Promise<VersionedPreset> {\n+    let current = preset;\n+    const path = this.getMigrationPath(preset.version, targetVersion);\n+\n+    for (const step of path) {\n+      const migration = this.migrations.get(step);\n+      if (!migration) {\n+        throw new Error(`No migration found for ${step}`);\n+      }\n+      current = await migration(current);\n+    }\n+\n+    return current;\n+  }\n+\n+  private migrateV1toV2(preset: VersionedPreset): VersionedPreset {\n+    // Example: Rename filter properties\n+    const migrated = {\n+      ...preset,\n+      version: \"2.0.0\",\n+      gridState: {\n+        ...preset.gridState,\n+        filterModel: this.migrateFilterModelV1toV2(preset.gridState.filterModel),\n+      },\n+    };\n+\n+    return migrated;\n+  }\n+\n+  private migrateFilterModelV1toV2(filterModel?: any): any {\n+    if (!filterModel) return filterModel;\n+\n+    const migrated: any = {};\n+\n+    for (const [column, filter] of Object.entries(filterModel)) {\n+      // V1 used 'dateFrom', V2 uses 'startDate'\n+      if (filter && typeof filter === \"object\") {\n+        migrated[column] = {\n+          ...filter,\n+          startDate: (filter as any).dateFrom,\n+          endDate: (filter as any).dateTo,\n+        };\n+        delete migrated[column].dateFrom;\n+        delete migrated[column].dateTo;\n+      }\n+    }\n+\n+    return migrated;\n+  }\n+}\n+```\n+\n+## Migration Strategies\n+\n+### From Legacy Filter Systems\n+\n+Migrate from older filter storage systems:\n+\n+```typescript\n+async function migrateLegacyFilters() {\n+  // Check for legacy storage\n+  const legacyFilters = localStorage.getItem(\"app-saved-filters\");\n+  if (!legacyFilters) return;\n+\n+  try {\n+    const parsed = JSON.parse(legacyFilters);\n+    const { savePreset } = useFilterPresets({ gridApi });\n+\n+    // Convert each legacy filter\n+    for (const legacy of parsed) {\n+      await savePreset({\n+        name: legacy.filterName || \"Imported Filter\",\n+        description: `Imported from legacy system on ${new Date().toLocaleDateString()}`,\n+        gridState: {\n+          filterModel: convertLegacyFilterModel(legacy.filters),\n+          sortModel: legacy.sorting,\n+          columnState: legacy.columns,\n+        },\n+        tags: [\"imported\", \"legacy\"],\n+      });\n+    }\n+\n+    // Clean up legacy storage\n+    localStorage.removeItem(\"app-saved-filters\");\n+\n+    console.log(`Successfully migrated ${parsed.length} filters`);\n+  } catch (error) {\n+    console.error(\"Failed to migrate legacy filters:\", error);\n+  }\n+}\n+\n+function convertLegacyFilterModel(legacyFilters: any): any {\n+  // Map legacy filter structure to AG Grid filter model\n+  const filterModel: any = {};\n+\n+  for (const filter of legacyFilters) {\n+    filterModel[filter.field] = {\n+      type: mapLegacyFilterType(filter.operator),\n+      filter: filter.value,\n+      filterTo: filter.valueTo,\n+    };\n+  }\n+\n+  return filterModel;\n+}\n+```\n+\n+### Gradual Migration Strategy\n+\n+For large applications, implement gradual migration:\n+\n+```typescript\n+class GradualMigrationService {\n+  private migrationFlags = {\n+    useNewPresetSystem: false,\n+    migrateOnAccess: true,\n+    dualWrite: true,\n+  };\n+\n+  async getPreset(id: string): Promise<Preset | null> {\n+    if (this.migrationFlags.useNewPresetSystem) {\n+      return this.newStorage.get(id);\n+    }\n+\n+    // Try legacy first\n+    const legacy = await this.legacyStorage.get(id);\n+    if (!legacy) return null;\n+\n+    // Migrate on access if enabled\n+    if (this.migrationFlags.migrateOnAccess) {\n+      const migrated = this.migrateLegacyPreset(legacy);\n+      await this.newStorage.save(migrated);\n+    }\n+\n+    return legacy;\n+  }\n+\n+  async savePreset(preset: Preset): Promise<void> {\n+    if (this.migrationFlags.dualWrite) {\n+      // Write to both systems during transition\n+      await Promise.all([this.newStorage.save(preset), this.legacyStorage.save(this.convertToLegacy(preset))]);\n+    } else if (this.migrationFlags.useNewPresetSystem) {\n+      await this.newStorage.save(preset);\n+    } else {\n+      await this.legacyStorage.save(this.convertToLegacy(preset));\n+    }\n+  }\n+\n+  async completeMigration() {\n+    // Migrate all remaining presets\n+    const legacyPresets = await this.legacyStorage.getAll();\n+\n+    for (const legacy of legacyPresets) {\n+      const migrated = this.migrateLegacyPreset(legacy);\n+      await this.newStorage.save(migrated);\n+    }\n+\n+    // Update flags\n+    this.migrationFlags = {\n+      useNewPresetSystem: true,\n+      migrateOnAccess: false,\n+      dualWrite: false,\n+    };\n+\n+    // Clean up legacy storage\n+    await this.legacyStorage.clear();\n+  }\n+}\n+```\n+\n+## Performance Benchmarks\n+\n+Monitor and optimize preset operations:\n+\n+```typescript\n+class PresetPerformanceMonitor {\n+  private metrics: Map<string, PerformanceMetric[]> = new Map();\n+\n+  async measure<T>(operation: string, fn: () => Promise<T>): Promise<T> {\n+    const start = performance.now();\n+\n+    try {\n+      const result = await fn();\n+      const duration = performance.now() - start;\n+\n+      this.recordMetric(operation, {\n+        duration,\n+        timestamp: Date.now(),\n+        success: true,\n+      });\n+\n+      return result;\n+    } catch (error) {\n+      const duration = performance.now() - start;\n+\n+      this.recordMetric(operation, {\n+        duration,\n+        timestamp: Date.now(),\n+        success: false,\n+        error: error.message,\n+      });\n+\n+      throw error;\n+    }\n+  }\n+\n+  getReport(): PerformanceReport {\n+    const report: PerformanceReport = {};\n+\n+    for (const [operation, metrics] of this.metrics) {\n+      const durations = metrics.map((m) => m.duration);\n+\n+      report[operation] = {\n+        count: metrics.length,\n+        avgDuration: durations.reduce((a, b) => a + b, 0) / durations.length,\n+        minDuration: Math.min(...durations),\n+        maxDuration: Math.max(...durations),\n+        p95Duration: this.percentile(durations, 0.95),\n+        errorRate: metrics.filter((m) => !m.success).length / metrics.length,\n+      };\n+    }\n+\n+    return report;\n+  }\n+\n+  private percentile(values: number[], p: number): number {\n+    const sorted = values.slice().sort((a, b) => a - b);\n+    const index = Math.ceil(sorted.length * p) - 1;\n+    return sorted[index];\n+  }\n+}\n+\n+// Usage\n+const monitor = new PresetPerformanceMonitor();\n+\n+const { savePreset } = useFilterPresets({\n+  gridApi,\n+  storage: {\n+    save: async (preset) => {\n+      return monitor.measure(\"preset.save\", async () => {\n+        await storage.save(preset);\n+      });\n+    },\n+    get: async (id) => {\n+      return monitor.measure(\"preset.get\", async () => {\n+        return storage.get(id);\n+      });\n+    },\n+  },\n+});\n+\n+// Get performance report\n+setInterval(() => {\n+  const report = monitor.getReport();\n+  console.log(\"Preset Performance:\", report);\n+\n+  // Send to analytics\n+  analytics.track(\"preset_performance\", report);\n+}, 60000); // Every minute\n+```\n+\n+## Best Practices Summary\n+\n+1. **Always sanitize user input** before saving or applying presets\n+2. **Use compression** for large filter models and URL sharing\n+3. **Implement proper error handling** with user-friendly messages\n+4. **Version your preset schema** to handle future changes\n+5. **Monitor performance** and optimize based on usage patterns\n+6. **Consider privacy regulations** when storing user data\n+7. **Implement gradual migration** for legacy systems\n+8. **Use appropriate storage** based on data size and requirements\n+9. **Validate preset data** both client and server-side\n+10. **Provide clear feedback** during long operations\ndiff --git a/docs/filter-presets/api-reference.md b/docs/filter-presets/api-reference.md\nnew file mode 100644\nindex 0000000..ccb2d32\n--- /dev/null\n+++ b/docs/filter-presets/api-reference.md\n@@ -0,0 +1,624 @@\n+# API Reference\n+\n+This document provides a comprehensive API reference for all filter preset components, hooks, and utilities.\n+\n+## Components\n+\n+### QuickFilterDropdown\n+\n+The main component for quick filtering with preset support.\n+\n+#### Props\n+\n+```typescript\n+interface QuickFilterDropdownProps {\n+  /** Column definitions from AG Grid */\n+  columns: ColDef[];\n+\n+  /** Callback when a filter is applied */\n+  onFilterApplied?: (filter: QuickFilterOption) => void;\n+\n+  /** Enable preset functionality */\n+  enablePresets?: PresetConfig;\n+\n+  /** Custom placeholder text */\n+  placeholder?: string;\n+\n+  /** Position of the dropdown */\n+  position?: \"left\" | \"right\" | \"center\";\n+\n+  /** Custom CSS class */\n+  className?: string;\n+\n+  /** Use portal for rendering */\n+  usePortal?: \"always\" | \"mobile\" | \"never\";\n+\n+  /** Maximum dropdown height */\n+  maxHeight?: number;\n+}\n+```\n+\n+#### PresetConfig Interface\n+\n+```typescript\n+interface PresetConfig {\n+  /** Allow users to save their own presets */\n+  allowUserPresets?: boolean;\n+\n+  /** Maximum number of user presets (default: 10) */\n+  maxUserPresets?: number;\n+\n+  /** System-defined presets */\n+  systemPresets?: SystemPreset[];\n+\n+  /** Default preset to load on initialization */\n+  defaultPresetId?: string;\n+\n+  /** Storage key for user presets (default: 'ag-grid-filter-presets') */\n+  storageKey?: string;\n+\n+  /** Callback when a preset is saved */\n+  onPresetSaved?: (preset: UserPreset) => void;\n+\n+  /** Callback when a preset is deleted */\n+  onPresetDeleted?: (presetId: string) => void;\n+\n+  /** Callback when a preset is loaded */\n+  onPresetLoaded?: (preset: Preset) => void;\n+}\n+```\n+\n+#### Example Usage\n+\n+```typescript\n+<QuickFilterDropdown\n+  columns={columnDefs}\n+  enablePresets={{\n+    allowUserPresets: true,\n+    maxUserPresets: 20,\n+    systemPresets: [\n+      {\n+        id: 'recent',\n+        name: 'Recent Items',\n+        gridState: {\n+          filterModel: {\n+            date: { type: 'after', mode: 'relative', expressionFrom: 'Today-7d' }\n+          }\n+        }\n+      }\n+    ],\n+    defaultPresetId: 'recent'\n+  }}\n+  onFilterApplied={(filter) => {\n+    gridApi.setFilterModel(filter.filterModel);\n+  }}\n+/>\n+```\n+\n+### FilterPresetManager\n+\n+A dedicated component for managing filter presets.\n+\n+#### Props\n+\n+```typescript\n+interface FilterPresetManagerProps {\n+  /** AG Grid API instance */\n+  gridApi: GridApi;\n+\n+  /** Column API instance */\n+  columnApi?: ColumnApi;\n+\n+  /** Position of the preset manager */\n+  position?: \"top-left\" | \"top-right\" | \"bottom-left\" | \"bottom-right\";\n+\n+  /** Show as modal or inline */\n+  displayMode?: \"modal\" | \"inline\" | \"dropdown\";\n+\n+  /** System presets */\n+  systemPresets?: SystemPreset[];\n+\n+  /** Storage configuration */\n+  storage?: PresetStorageConfig;\n+\n+  /** Custom styling */\n+  className?: string;\n+\n+  /** Theme */\n+  theme?: \"light\" | \"dark\" | \"auto\";\n+}\n+```\n+\n+#### Example Usage\n+\n+```typescript\n+<FilterPresetManager\n+  gridApi={gridApi}\n+  position=\"top-right\"\n+  displayMode=\"dropdown\"\n+  systemPresets={systemPresets}\n+  storage={{\n+    adapter: 'localStorage',\n+    maxPresets: 50,\n+    compression: true\n+  }}\n+/>\n+```\n+\n+## Hooks\n+\n+### useFilterPresets\n+\n+Hook for managing filter presets programmatically.\n+\n+#### Parameters\n+\n+```typescript\n+interface UseFilterPresetsParams {\n+  /** AG Grid API instance */\n+  gridApi: GridApi;\n+\n+  /** Storage key */\n+  storageKey?: string;\n+\n+  /** Storage adapter */\n+  storage?: PresetStorageAdapter;\n+\n+  /** System presets */\n+  systemPresets?: SystemPreset[];\n+\n+  /** Auto-save current filters */\n+  autoSave?: boolean;\n+\n+  /** Auto-save delay in ms (default: 1000) */\n+  autoSaveDelay?: number;\n+}\n+```\n+\n+#### Returns\n+\n+```typescript\n+interface UseFilterPresetsReturn {\n+  /** All presets (system + user) */\n+  presets: Preset[];\n+\n+  /** User presets only */\n+  userPresets: UserPreset[];\n+\n+  /** System presets only */\n+  systemPresets: SystemPreset[];\n+\n+  /** Currently active preset */\n+  activePreset: Preset | null;\n+\n+  /** Save current filters as preset */\n+  savePreset: (options: SavePresetOptions) => Promise<UserPreset>;\n+\n+  /** Load a preset */\n+  loadPreset: (presetId: string) => Promise<void>;\n+\n+  /** Update existing preset */\n+  updatePreset: (presetId: string, updates: PresetUpdates) => Promise<void>;\n+\n+  /** Delete a preset */\n+  deletePreset: (presetId: string) => Promise<void>;\n+\n+  /** Export presets */\n+  exportPresets: () => Promise<string>;\n+\n+  /** Import presets */\n+  importPresets: (data: string) => Promise<ImportResult>;\n+\n+  /** Generate shareable URL */\n+  getShareableUrl: (presetId?: string) => string;\n+\n+  /** Check if can save more presets */\n+  canSavePreset: boolean;\n+\n+  /** Loading state */\n+  isLoading: boolean;\n+\n+  /** Error state */\n+  error: Error | null;\n+}\n+```\n+\n+#### Example Usage\n+\n+```typescript\n+function MyFilterControls({ gridApi }) {\n+  const {\n+    presets,\n+    savePreset,\n+    loadPreset,\n+    deletePreset,\n+    activePreset,\n+    canSavePreset\n+  } = useFilterPresets({\n+    gridApi,\n+    storageKey: 'my-app-filters',\n+    autoSave: true,\n+    systemPresets: defaultPresets\n+  });\n+\n+  const handleSave = async () => {\n+    const preset = await savePreset({\n+      name: 'My Filter Set',\n+      description: 'Filters for Q4 analysis',\n+      tags: ['quarterly', 'analysis']\n+    });\n+    console.log('Saved preset:', preset);\n+  };\n+\n+  return (\n+    <div>\n+      <select onChange={(e) => loadPreset(e.target.value)}>\n+        {presets.map(preset => (\n+          <option key={preset.id} value={preset.id}>\n+            {preset.name} {preset.id === activePreset?.id && '(active)'}\n+          </option>\n+        ))}\n+      </select>\n+\n+      <button onClick={handleSave} disabled={!canSavePreset}>\n+        Save Current Filters\n+      </button>\n+    </div>\n+  );\n+}\n+```\n+\n+### usePresetStorage\n+\n+Low-level hook for preset storage operations.\n+\n+#### Parameters\n+\n+```typescript\n+interface UsePresetStorageParams {\n+  /** Storage key */\n+  key?: string;\n+\n+  /** Storage adapter */\n+  adapter?: \"localStorage\" | \"sessionStorage\" | \"indexedDB\" | PresetStorageAdapter;\n+\n+  /** Enable compression */\n+  compression?: boolean;\n+\n+  /** Max storage size in bytes */\n+  maxSize?: number;\n+}\n+```\n+\n+#### Returns\n+\n+```typescript\n+interface UsePresetStorageReturn {\n+  /** Get all stored presets */\n+  getPresets: () => Promise<UserPreset[]>;\n+\n+  /** Get a single preset */\n+  getPreset: (id: string) => Promise<UserPreset | null>;\n+\n+  /** Save a preset */\n+  savePreset: (preset: UserPreset) => Promise<void>;\n+\n+  /** Update a preset */\n+  updatePreset: (id: string, updates: Partial<UserPreset>) => Promise<void>;\n+\n+  /** Delete a preset */\n+  deletePreset: (id: string) => Promise<void>;\n+\n+  /** Clear all presets */\n+  clearPresets: () => Promise<void>;\n+\n+  /** Get storage info */\n+  getStorageInfo: () => Promise<StorageInfo>;\n+\n+  /** Storage quota exceeded */\n+  isQuotaExceeded: boolean;\n+}\n+```\n+\n+## Utility Functions\n+\n+### createPresetStorage\n+\n+Factory function for creating custom storage adapters.\n+\n+```typescript\n+function createPresetStorage(options: StorageOptions): PresetStorageAdapter;\n+\n+interface StorageOptions {\n+  /** Storage type */\n+  adapter: \"localStorage\" | \"sessionStorage\" | \"indexedDB\";\n+\n+  /** Database name (for IndexedDB) */\n+  dbName?: string;\n+\n+  /** Object store name (for IndexedDB) */\n+  storeName?: string;\n+\n+  /** Enable compression */\n+  compression?: boolean;\n+\n+  /** Encryption key (optional) */\n+  encryptionKey?: string;\n+}\n+```\n+\n+### parseShareableUrl\n+\n+Parse a shareable URL to extract preset data.\n+\n+```typescript\n+function parseShareableUrl(url: string): ShareableUrlData | null;\n+\n+interface ShareableUrlData {\n+  /** Preset ID if referencing saved preset */\n+  presetId?: string;\n+\n+  /** Inline filter model */\n+  filterModel?: FilterModel;\n+\n+  /** Grid state including sorting, grouping */\n+  gridState?: Partial<GridState>;\n+\n+  /** Compression used */\n+  compressed?: boolean;\n+\n+  /** Version for compatibility */\n+  version?: string;\n+}\n+```\n+\n+### validatePreset\n+\n+Validate preset data structure.\n+\n+```typescript\n+function validatePreset(preset: unknown): ValidationResult;\n+\n+interface ValidationResult {\n+  /** Whether preset is valid */\n+  isValid: boolean;\n+\n+  /** Validation errors */\n+  errors: ValidationError[];\n+\n+  /** Sanitized preset data */\n+  sanitized?: Preset;\n+}\n+```\n+\n+### migratePresets\n+\n+Migrate presets from older versions.\n+\n+```typescript\n+function migratePresets(presets: unknown[], fromVersion: string, toVersion: string): MigrationResult;\n+\n+interface MigrationResult {\n+  /** Migrated presets */\n+  presets: Preset[];\n+\n+  /** Migration report */\n+  report: {\n+    successful: number;\n+    failed: number;\n+    errors: MigrationError[];\n+  };\n+}\n+```\n+\n+## TypeScript Interfaces\n+\n+### Core Types\n+\n+```typescript\n+/** Base preset interface */\n+interface Preset {\n+  /** Unique identifier */\n+  id: string;\n+\n+  /** Display name */\n+  name: string;\n+\n+  /** Optional description */\n+  description?: string;\n+\n+  /** Grid state including filters */\n+  gridState: Partial<GridState>;\n+\n+  /** Creation timestamp */\n+  createdAt: string;\n+\n+  /** Last modified timestamp */\n+  updatedAt: string;\n+\n+  /** Preset type */\n+  type: \"system\" | \"user\";\n+\n+  /** Optional tags */\n+  tags?: string[];\n+\n+  /** Usage count */\n+  usageCount?: number;\n+}\n+\n+/** System preset (read-only) */\n+interface SystemPreset extends Preset {\n+  type: \"system\";\n+\n+  /** Optional icon */\n+  icon?: string;\n+\n+  /** Display order */\n+  order?: number;\n+\n+  /** Preset category */\n+  category?: string;\n+}\n+\n+/** User preset (mutable) */\n+interface UserPreset extends Preset {\n+  type: \"user\";\n+\n+  /** User who created it */\n+  createdBy?: string;\n+\n+  /** Sharing settings */\n+  sharing?: {\n+    enabled: boolean;\n+    url?: string;\n+    expiresAt?: string;\n+  };\n+}\n+\n+/** Grid state structure */\n+interface GridState {\n+  /** Filter model */\n+  filterModel: FilterModel;\n+\n+  /** Sort model */\n+  sortModel?: SortModelItem[];\n+\n+  /** Column state */\n+  columnState?: ColumnState[];\n+\n+  /** Group state */\n+  groupState?: GroupState;\n+\n+  /** Pagination state */\n+  paginationState?: PaginationState;\n+}\n+```\n+\n+### Storage Types\n+\n+```typescript\n+/** Storage adapter interface */\n+interface PresetStorageAdapter {\n+  /** Get all presets */\n+  getAll(): Promise<UserPreset[]>;\n+\n+  /** Get single preset */\n+  get(id: string): Promise<UserPreset | null>;\n+\n+  /** Save preset */\n+  save(preset: UserPreset): Promise<void>;\n+\n+  /** Update preset */\n+  update(id: string, updates: Partial<UserPreset>): Promise<void>;\n+\n+  /** Delete preset */\n+  delete(id: string): Promise<void>;\n+\n+  /** Clear all presets */\n+  clear(): Promise<void>;\n+\n+  /** Get storage info */\n+  getInfo(): Promise<StorageInfo>;\n+}\n+\n+/** Storage info */\n+interface StorageInfo {\n+  /** Used space in bytes */\n+  used: number;\n+\n+  /** Available space in bytes */\n+  available: number;\n+\n+  /** Total quota in bytes */\n+  quota: number;\n+\n+  /** Number of presets */\n+  count: number;\n+\n+  /** Compression enabled */\n+  compressed: boolean;\n+}\n+```\n+\n+### Event Types\n+\n+```typescript\n+/** Preset events */\n+interface PresetEvents {\n+  /** Fired when preset is saved */\n+  onPresetSaved: (preset: UserPreset) => void;\n+\n+  /** Fired when preset is loaded */\n+  onPresetLoaded: (preset: Preset) => void;\n+\n+  /** Fired when preset is deleted */\n+  onPresetDeleted: (presetId: string) => void;\n+\n+  /** Fired when preset is updated */\n+  onPresetUpdated: (preset: UserPreset) => void;\n+\n+  /** Fired when presets are imported */\n+  onPresetsImported: (result: ImportResult) => void;\n+\n+  /** Fired when storage quota exceeded */\n+  onQuotaExceeded: (info: StorageInfo) => void;\n+}\n+```\n+\n+## Error Handling\n+\n+All preset operations can throw these error types:\n+\n+```typescript\n+/** Base preset error */\n+class PresetError extends Error {\n+  code: string;\n+  details?: unknown;\n+}\n+\n+/** Storage quota exceeded */\n+class QuotaExceededError extends PresetError {\n+  code = \"QUOTA_EXCEEDED\";\n+  storageInfo: StorageInfo;\n+}\n+\n+/** Preset not found */\n+class PresetNotFoundError extends PresetError {\n+  code = \"PRESET_NOT_FOUND\";\n+  presetId: string;\n+}\n+\n+/** Invalid preset data */\n+class InvalidPresetError extends PresetError {\n+  code = \"INVALID_PRESET\";\n+  validationErrors: ValidationError[];\n+}\n+\n+/** Import/export errors */\n+class ImportExportError extends PresetError {\n+  code = \"IMPORT_EXPORT_ERROR\";\n+  phase: \"parse\" | \"validate\" | \"save\";\n+}\n+```\n+\n+## Browser Storage Events\n+\n+Listen for cross-tab preset updates:\n+\n+```typescript\n+// Listen for storage events\n+window.addEventListener(\"storage\", (e) => {\n+  if (e.key === \"ag-grid-filter-presets\") {\n+    // Presets updated in another tab\n+    const updatedPresets = JSON.parse(e.newValue || \"[]\");\n+    // Update your UI accordingly\n+  }\n+});\n+\n+// Using the hook\n+const { presets } = useFilterPresets({\n+  gridApi,\n+  // Automatically syncs across tabs\n+  syncAcrossTabs: true,\n+});\n+```\ndiff --git a/docs/filter-presets/getting-started.md b/docs/filter-presets/getting-started.md\nnew file mode 100644\nindex 0000000..dc1cb49\n--- /dev/null\n+++ b/docs/filter-presets/getting-started.md\n@@ -0,0 +1,353 @@\n+# Filter Presets Guide\n+\n+Filter presets provide a powerful way to save, share, and reuse filter configurations in your AG Grid applications. This guide will help you understand the core concepts and get started quickly.\n+\n+## Quick Start\n+\n+### Installing and Basic Setup\n+\n+The filter preset functionality is built into the `ag-grid-react-components` package:\n+\n+```bash\n+npm install ag-grid-react-components\n+```\n+\n+### Your First Preset\n+\n+Here's how to enable filter presets with the QuickFilterDropdown component:\n+\n+```typescript\n+import { QuickFilterDropdown } from 'ag-grid-react-components';\n+\n+function MyGrid() {\n+  const [columnDefs] = useState([\n+    { field: 'date', filter: 'agDateColumnFilter' },\n+    { field: 'status', filter: 'agTextColumnFilter' },\n+    { field: 'amount', filter: 'agNumberColumnFilter' }\n+  ]);\n+\n+  return (\n+    <div>\n+      <QuickFilterDropdown\n+        columns={columnDefs}\n+        enablePresets={{\n+          systemPresets: [\n+            {\n+              id: 'recent',\n+              name: 'Recent Activity',\n+              gridState: {\n+                filterModel: {\n+                  date: {\n+                    type: 'after',\n+                    mode: 'relative',\n+                    expressionFrom: 'Today-7d'\n+                  }\n+                }\n+              }\n+            },\n+            {\n+              id: 'high-value',\n+              name: 'High Value',\n+              gridState: {\n+                filterModel: {\n+                  amount: {\n+                    type: 'greaterThan',\n+                    filter: 1000\n+                  }\n+                }\n+              }\n+            }\n+          ]\n+        }}\n+        onFilterApplied={(filter) => {\n+          // Apply filter to your grid\n+          gridApi.setFilterModel(filter.filterModel);\n+        }}\n+      />\n+      {/* Your AG Grid component */}\n+    </div>\n+  );\n+}\n+```\n+\n+### Common Use Cases\n+\n+#### 1. Date Range Presets\n+\n+```typescript\n+const datePresets = [\n+  {\n+    id: \"today\",\n+    name: \"Today\",\n+    gridState: {\n+      filterModel: {\n+        date: { type: \"equals\", mode: \"relative\", expressionFrom: \"Today\" },\n+      },\n+    },\n+  },\n+  {\n+    id: \"this-week\",\n+    name: \"This Week\",\n+    gridState: {\n+      filterModel: {\n+        date: {\n+          type: \"inRange\",\n+          mode: \"relative\",\n+          expressionFrom: \"StartOfWeek\",\n+          expressionTo: \"EndOfWeek\",\n+        },\n+      },\n+    },\n+  },\n+  {\n+    id: \"last-30-days\",\n+    name: \"Last 30 Days\",\n+    gridState: {\n+      filterModel: {\n+        date: { type: \"after\", mode: \"relative\", expressionFrom: \"Today-30d\" },\n+      },\n+    },\n+  },\n+];\n+```\n+\n+#### 2. Status-Based Presets\n+\n+```typescript\n+const statusPresets = [\n+  {\n+    id: \"active\",\n+    name: \"Active Only\",\n+    gridState: {\n+      filterModel: {\n+        status: { type: \"equals\", filter: \"active\" },\n+      },\n+    },\n+  },\n+  {\n+    id: \"pending\",\n+    name: \"Pending Review\",\n+    gridState: {\n+      filterModel: {\n+        status: { type: \"equals\", filter: \"pending\" },\n+        assignedTo: { type: \"blank\" },\n+      },\n+    },\n+  },\n+];\n+```\n+\n+#### 3. Complex Multi-Column Presets\n+\n+```typescript\n+const complexPresets = [\n+  {\n+    id: \"priority-tasks\",\n+    name: \"Priority Tasks\",\n+    gridState: {\n+      filterModel: {\n+        priority: { type: \"equals\", filter: \"high\" },\n+        dueDate: {\n+          type: \"before\",\n+          mode: \"relative\",\n+          expressionFrom: \"Today+7d\",\n+        },\n+        status: { type: \"notEqual\", filter: \"completed\" },\n+      },\n+      sortModel: [{ colId: \"dueDate\", sort: \"asc\" }],\n+    },\n+  },\n+];\n+```\n+\n+## Core Concepts\n+\n+### System vs User Presets\n+\n+Filter presets come in two types:\n+\n+1. **System Presets**: Predefined by developers, available to all users\n+\n+   - Cannot be modified or deleted by users\n+   - Provide consistent filtering options across the application\n+   - Ideal for common use cases\n+\n+2. **User Presets**: Created and managed by individual users\n+   - Stored in browser localStorage\n+   - Can be created, updated, and deleted\n+   - Personal to each user\n+\n+### Default Preset Behavior\n+\n+You can specify a default preset that loads automatically:\n+\n+```typescript\n+<QuickFilterDropdown\n+  columns={columnDefs}\n+  enablePresets={{\n+    defaultPresetId: 'active', // Loads this preset by default\n+    systemPresets: presets\n+  }}\n+/>\n+```\n+\n+### Storage Limitations\n+\n+User presets are stored in browser localStorage, which has limitations:\n+\n+- **Storage Quota**: Typically 5-10MB per origin\n+- **Browser Support**: Works in all modern browsers\n+- **Privacy Mode**: Limited or no storage in private/incognito mode\n+- **Cross-Device**: Presets don't sync across devices\n+\n+### Browser Compatibility\n+\n+Filter presets work in all modern browsers:\n+\n+- Chrome 80+\n+- Firefox 75+\n+- Safari 13+\n+- Edge 80+\n+\n+For older browsers, the preset functionality gracefully degrades to basic filtering.\n+\n+## Integration Guide\n+\n+### With QuickFilterDropdown\n+\n+The QuickFilterDropdown component has built-in preset support:\n+\n+```typescript\n+<QuickFilterDropdown\n+  columns={columnDefs}\n+  enablePresets={{\n+    // Allow users to save their own presets\n+    allowUserPresets: true,\n+\n+    // Maximum user presets (default: 10)\n+    maxUserPresets: 20,\n+\n+    // System presets\n+    systemPresets: [...],\n+\n+    // Default preset\n+    defaultPresetId: 'recent'\n+  }}\n+  onPresetSaved={(preset) => {\n+    console.log('Preset saved:', preset);\n+  }}\n+  onPresetDeleted={(presetId) => {\n+    console.log('Preset deleted:', presetId);\n+  }}\n+/>\n+```\n+\n+### With Custom Filter UI\n+\n+You can also integrate presets with your custom filter UI:\n+\n+```typescript\n+import { useFilterPresets } from 'ag-grid-react-components';\n+\n+function CustomFilterUI({ gridApi }) {\n+  const {\n+    presets,\n+    savePreset,\n+    loadPreset,\n+    deletePreset,\n+    updatePreset\n+  } = useFilterPresets({\n+    gridApi,\n+    storageKey: 'my-app-filter-presets'\n+  });\n+\n+  const handleSaveCurrentFilters = () => {\n+    const currentFilters = gridApi.getFilterModel();\n+\n+    savePreset({\n+      name: 'My Custom Filter',\n+      filterModel: currentFilters,\n+      description: 'Filters for Q4 analysis'\n+    });\n+  };\n+\n+  return (\n+    <div>\n+      <button onClick={handleSaveCurrentFilters}>\n+        Save Current Filters\n+      </button>\n+\n+      <select onChange={(e) => loadPreset(e.target.value)}>\n+        <option value=\"\">Select a preset...</option>\n+        {presets.map(preset => (\n+          <option key={preset.id} value={preset.id}>\n+            {preset.name}\n+          </option>\n+        ))}\n+      </select>\n+    </div>\n+  );\n+}\n+```\n+\n+### With Existing Applications\n+\n+To add preset support to existing applications:\n+\n+1. **Update Grid Configuration**:\n+\n+```typescript\n+const gridOptions = {\n+  // Enable filter persistence\n+  suppressFilterPersistence: false,\n+\n+  // Handle filter changes\n+  onFilterChanged: (params) => {\n+    // Update URL or state as needed\n+  },\n+};\n+```\n+\n+2. **Add Preset UI**:\n+\n+```typescript\n+import { FilterPresetManager } from 'ag-grid-react-components';\n+\n+function MyApp() {\n+  return (\n+    <>\n+      <FilterPresetManager\n+        gridApi={gridApi}\n+        position=\"top-right\"\n+      />\n+      <AgGridReact {...gridOptions} />\n+    </>\n+  );\n+}\n+```\n+\n+3. **Migrate Existing Filters**:\n+\n+```typescript\n+// Convert existing saved filters to presets\n+const migrateFilters = () => {\n+  const oldFilters = localStorage.getItem(\"saved-filters\");\n+  if (oldFilters) {\n+    const filters = JSON.parse(oldFilters);\n+    filters.forEach((filter) => {\n+      savePreset({\n+        name: filter.name,\n+        filterModel: filter.model,\n+        createdAt: new Date().toISOString(),\n+      });\n+    });\n+  }\n+};\n+```\n+\n+## Next Steps\n+\n+- Read the [API Reference](./api-reference.md) for detailed component documentation\n+- Explore [Advanced Topics](./advanced-usage.md) for performance optimization and custom storage\n+- Check out the [Troubleshooting Guide](./troubleshooting.md) for common issues\n+- See the [Migration Guide](./migration-guide.md) for upgrading from older versions\ndiff --git a/docs/filter-presets/migration-guide.md b/docs/filter-presets/migration-guide.md\nnew file mode 100644\nindex 0000000..af1e83d\n--- /dev/null\n+++ b/docs/filter-presets/migration-guide.md\n@@ -0,0 +1,538 @@\n+# Migration Guide\n+\n+This guide helps you migrate to the filter preset system from various existing implementations.\n+\n+## For Existing QuickFilterDropdown Users\n+\n+If you're already using QuickFilterDropdown, enabling presets is straightforward:\n+\n+### Before (v0.x)\n+\n+```typescript\n+<QuickFilterDropdown\n+  columns={columnDefs}\n+  onFilterApplied={(filter) => {\n+    gridApi.setFilterModel(filter.filterModel);\n+  }}\n+/>\n+```\n+\n+### After (v1.0)\n+\n+```typescript\n+<QuickFilterDropdown\n+  columns={columnDefs}\n+  onFilterApplied={(filter) => {\n+    gridApi.setFilterModel(filter.filterModel);\n+  }}\n+  enablePresets={{\n+    systemPresets: [\n+      {\n+        id: 'recent',\n+        name: 'Recent Activity',\n+        gridState: {\n+          filterModel: {\n+            date: { type: 'after', mode: 'relative', expressionFrom: 'Today-7d' }\n+          }\n+        }\n+      }\n+    ]\n+  }}\n+/>\n+```\n+\n+**Key Points**:\n+\n+- ✅ No breaking changes to existing functionality\n+- ✅ Presets are opt-in via `enablePresets` prop\n+- ✅ All existing props and callbacks continue to work\n+- ✅ Backward compatible with all versions\n+\n+## For Custom Filter Implementations\n+\n+If you have a custom filter UI, you can integrate the preset system:\n+\n+### Step 1: Install the Package\n+\n+```bash\n+npm install ag-grid-react-components@latest\n+```\n+\n+### Step 2: Add Preset Hook\n+\n+```typescript\n+import { useFilterPresets } from 'ag-grid-react-components';\n+\n+function MyCustomFilters({ gridApi }) {\n+  // Your existing filter logic\n+  const [filters, setFilters] = useState({});\n+\n+  // Add preset support\n+  const {\n+    presets,\n+    savePreset,\n+    loadPreset,\n+    activePreset\n+  } = useFilterPresets({\n+    gridApi,\n+    systemPresets: [\n+      // Your default presets\n+    ]\n+  });\n+\n+  // Your existing filter UI\n+  return (\n+    <div>\n+      {/* Add preset selector */}\n+      <select\n+        value={activePreset?.id || ''}\n+        onChange={(e) => loadPreset(e.target.value)}\n+      >\n+        <option value=\"\">Custom Filters</option>\n+        {presets.map(preset => (\n+          <option key={preset.id} value={preset.id}>\n+            {preset.name}\n+          </option>\n+        ))}\n+      </select>\n+\n+      {/* Your existing filter controls */}\n+      <MyFilterControls\n+        filters={filters}\n+        onChange={setFilters}\n+      />\n+\n+      {/* Add save preset button */}\n+      <button onClick={() => {\n+        savePreset({\n+          name: 'My Filters',\n+          gridState: { filterModel: filters }\n+        });\n+      }}>\n+        Save Current Filters\n+      </button>\n+    </div>\n+  );\n+}\n+```\n+\n+### Step 3: Migration Checklist\n+\n+- [ ] Install latest version of ag-grid-react-components\n+- [ ] Import `useFilterPresets` hook\n+- [ ] Add preset UI elements (selector, save button)\n+- [ ] Configure system presets if needed\n+- [ ] Test saving and loading presets\n+- [ ] Add error handling for storage issues\n+- [ ] Update documentation for users\n+\n+## From URL-Based Filter Persistence\n+\n+If you're currently using URL parameters for filter persistence:\n+\n+### Before\n+\n+```typescript\n+// Manual URL handling\n+function MyGrid() {\n+  useEffect(() => {\n+    // Load from URL\n+    const params = new URLSearchParams(location.search);\n+    const filters = params.get(\"filters\");\n+    if (filters) {\n+      try {\n+        const decoded = JSON.parse(atob(filters));\n+        gridApi.setFilterModel(decoded);\n+      } catch (e) {\n+        console.error(\"Invalid filter URL\");\n+      }\n+    }\n+  }, []);\n+\n+  const saveToUrl = (filters) => {\n+    const encoded = btoa(JSON.stringify(filters));\n+    const url = new URL(location.href);\n+    url.searchParams.set(\"filters\", encoded);\n+    history.pushState({}, \"\", url);\n+  };\n+\n+  // ...\n+}\n+```\n+\n+### After\n+\n+```typescript\n+// Using built-in URL sync\n+function MyGrid() {\n+  const { getShareableUrl, loadFromUrl } = useFilterPresets({\n+    gridApi,\n+    urlSync: true, // Enable automatic URL synchronization\n+    compression: true, // Use compression for shorter URLs\n+  });\n+\n+  useEffect(() => {\n+    // Automatically loads from URL\n+    loadFromUrl();\n+  }, []);\n+\n+  const shareFilters = () => {\n+    const url = getShareableUrl();\n+    navigator.clipboard.writeText(url);\n+    showNotification(\"Share link copied!\");\n+  };\n+\n+  // ...\n+}\n+```\n+\n+### Benefits of Migration\n+\n+- ✅ Automatic compression for shorter URLs\n+- ✅ Built-in error handling and validation\n+- ✅ Support for full grid state (not just filters)\n+- ✅ Browser back/forward navigation support\n+- ✅ Cross-browser compatibility\n+\n+## From localStorage Filter Saving\n+\n+If you have custom localStorage implementation:\n+\n+### Before\n+\n+```typescript\n+// Custom localStorage implementation\n+const STORAGE_KEY = \"saved-filters\";\n+\n+function saveFilters(name: string, filters: any) {\n+  const saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || \"[]\");\n+  saved.push({\n+    id: Date.now().toString(),\n+    name,\n+    filters,\n+    date: new Date().toISOString(),\n+  });\n+  localStorage.setItem(STORAGE_KEY, JSON.stringify(saved));\n+}\n+\n+function loadFilters() {\n+  return JSON.parse(localStorage.getItem(STORAGE_KEY) || \"[]\");\n+}\n+\n+function deleteFilter(id: string) {\n+  const saved = loadFilters().filter((f) => f.id !== id);\n+  localStorage.setItem(STORAGE_KEY, JSON.stringify(saved));\n+}\n+```\n+\n+### After\n+\n+```typescript\n+// Using preset system\n+const { presets, savePreset, deletePreset, userPresets } = useFilterPresets({\n+  gridApi,\n+  storage: {\n+    adapter: \"localStorage\",\n+    compression: true,\n+    maxPresets: 50,\n+  },\n+});\n+\n+// Compatible API\n+async function saveFilters(name: string, filters: any) {\n+  await savePreset({\n+    name,\n+    gridState: { filterModel: filters },\n+  });\n+}\n+\n+function loadFilters() {\n+  return userPresets; // Already loaded and validated\n+}\n+\n+async function deleteFilter(id: string) {\n+  await deletePreset(id);\n+}\n+```\n+\n+### Migration Script\n+\n+```typescript\n+// One-time migration of existing saved filters\n+async function migrateExistingFilters() {\n+  const oldFilters = JSON.parse(localStorage.getItem(\"saved-filters\") || \"[]\");\n+\n+  if (oldFilters.length === 0) return;\n+\n+  console.log(`Migrating ${oldFilters.length} saved filters...`);\n+\n+  const { savePreset } = useFilterPresets({ gridApi });\n+\n+  for (const old of oldFilters) {\n+    try {\n+      await savePreset({\n+        name: old.name,\n+        gridState: { filterModel: old.filters },\n+        createdAt: old.date || new Date().toISOString(),\n+        tags: [\"migrated\"],\n+      });\n+    } catch (error) {\n+      console.error(`Failed to migrate filter \"${old.name}\":`, error);\n+    }\n+  }\n+\n+  // Backup old data\n+  localStorage.setItem(\"saved-filters.backup\", JSON.stringify(oldFilters));\n+\n+  // Remove old storage\n+  localStorage.removeItem(\"saved-filters\");\n+\n+  console.log(\"Migration completed!\");\n+}\n+```\n+\n+## From Server-Side Filter Storage\n+\n+If you store filters on the server:\n+\n+### Hybrid Approach (Recommended)\n+\n+```typescript\n+// Combine local and server storage\n+class HybridPresetStorage implements PresetStorageAdapter {\n+  constructor(\n+    private apiClient: ApiClient,\n+    private localStorage: PresetStorageAdapter,\n+  ) {}\n+\n+  async getAll(): Promise<UserPreset[]> {\n+    // Try local first for performance\n+    const local = await this.localStorage.getAll();\n+\n+    // Sync with server in background\n+    this.syncWithServer();\n+\n+    return local;\n+  }\n+\n+  async save(preset: UserPreset): Promise<void> {\n+    // Save locally first\n+    await this.localStorage.save(preset);\n+\n+    // Sync to server (don't block UI)\n+    this.apiClient.savePreset(preset).catch((error) => {\n+      console.error(\"Failed to sync preset to server:\", error);\n+      // Mark for retry\n+      this.markForSync(preset.id);\n+    });\n+  }\n+\n+  private async syncWithServer() {\n+    try {\n+      const serverPresets = await this.apiClient.getPresets();\n+      const localPresets = await this.localStorage.getAll();\n+\n+      // Merge based on updatedAt timestamp\n+      const merged = this.mergePresets(serverPresets, localPresets);\n+\n+      // Update local storage\n+      for (const preset of merged) {\n+        await this.localStorage.save(preset);\n+      }\n+    } catch (error) {\n+      console.error(\"Sync failed:\", error);\n+    }\n+  }\n+}\n+\n+// Usage\n+const storage = new HybridPresetStorage(apiClient, localStorage);\n+\n+const { presets, savePreset } = useFilterPresets({\n+  gridApi,\n+  storage,\n+});\n+```\n+\n+### Full Server Migration\n+\n+```typescript\n+// Server-only storage adapter\n+class ServerStorage implements PresetStorageAdapter {\n+  constructor(private apiEndpoint: string) {}\n+\n+  async getAll(): Promise<UserPreset[]> {\n+    const response = await fetch(`${this.apiEndpoint}/presets`, {\n+      credentials: \"include\",\n+    });\n+\n+    if (!response.ok) {\n+      throw new Error(\"Failed to fetch presets\");\n+    }\n+\n+    return response.json();\n+  }\n+\n+  async save(preset: UserPreset): Promise<void> {\n+    const response = await fetch(`${this.apiEndpoint}/presets`, {\n+      method: \"POST\",\n+      credentials: \"include\",\n+      headers: { \"Content-Type\": \"application/json\" },\n+      body: JSON.stringify(preset),\n+    });\n+\n+    if (!response.ok) {\n+      throw new Error(\"Failed to save preset\");\n+    }\n+  }\n+\n+  // Implement other methods...\n+}\n+\n+// Usage\n+const { presets, savePreset } = useFilterPresets({\n+  gridApi,\n+  storage: new ServerStorage(\"/api\"),\n+});\n+```\n+\n+## Breaking Changes\n+\n+### Version 0.x to 1.0\n+\n+While we've maintained backward compatibility, some internal changes may affect advanced usage:\n+\n+1. **Storage Format Changed**\n+\n+   - Old format: `{ filters: [...], name: string }`\n+   - New format: `{ gridState: { filterModel: {...} }, name: string, ... }`\n+   - Migration is automatic\n+\n+2. **Date Serialization**\n+\n+   - Old: Dates stored as ISO strings\n+   - New: Dates stored with timezone information\n+   - Both formats are supported\n+\n+3. **URL Parameter Names**\n+   - Old: `?filters=...`\n+   - New: `?p=...` (shorter, supports more data)\n+   - Old URLs continue to work\n+\n+### Deprecations\n+\n+The following features are deprecated and will be removed in v2.0:\n+\n+```typescript\n+// Deprecated - use enablePresets instead\n+<QuickFilterDropdown\n+  savedFilters={filters} // ❌ Deprecated\n+  onSaveFilter={save}    // ❌ Deprecated\n+/>\n+\n+// New way\n+<QuickFilterDropdown\n+  enablePresets={{\n+    systemPresets: filters,\n+    onPresetSaved: save\n+  }}\n+/>\n+```\n+\n+## Testing Your Migration\n+\n+### Unit Tests\n+\n+```typescript\n+describe(\"Filter Preset Migration\", () => {\n+  it(\"should load legacy filters\", async () => {\n+    // Setup legacy data\n+    localStorage.setItem(\"saved-filters\", JSON.stringify([{ id: \"1\", name: \"Old Filter\", filters: { status: \"active\" } }]));\n+\n+    // Run migration\n+    await migrateExistingFilters();\n+\n+    // Verify migrated\n+    const { presets } = renderHook(() => useFilterPresets({ gridApi })).result.current;\n+\n+    expect(presets).toHaveLength(1);\n+    expect(presets[0].name).toBe(\"Old Filter\");\n+    expect(presets[0].gridState.filterModel).toEqual({\n+      status: \"active\",\n+    });\n+  });\n+});\n+```\n+\n+### E2E Tests\n+\n+```typescript\n+test(\"legacy filters should be accessible after migration\", async ({ page }) => {\n+  // Setup legacy filter in localStorage\n+  await page.evaluate(() => {\n+    localStorage.setItem(\"saved-filters\", JSON.stringify([{ id: \"1\", name: \"Legacy Filter\", filters: { date: \"recent\" } }]));\n+  });\n+\n+  // Navigate to app\n+  await page.goto(\"/\");\n+\n+  // Open preset dropdown\n+  await page.click('[data-testid=\"preset-dropdown\"]');\n+\n+  // Verify legacy filter appears\n+  await expect(page.locator(\"text=Legacy Filter\")).toBeVisible();\n+\n+  // Click to apply\n+  await page.click(\"text=Legacy Filter\");\n+\n+  // Verify filter applied\n+  await expect(page.locator(\".ag-filter-active\")).toBeVisible();\n+});\n+```\n+\n+## Rollback Plan\n+\n+If you need to rollback after migration:\n+\n+```typescript\n+// 1. Restore backup data\n+function rollbackMigration() {\n+  const backup = localStorage.getItem(\"saved-filters.backup\");\n+  if (backup) {\n+    localStorage.setItem(\"saved-filters\", backup);\n+    localStorage.removeItem(\"ag-grid-filter-presets\");\n+    location.reload();\n+  }\n+}\n+\n+// 2. Feature flag for gradual rollout\n+const useNewPresets = localStorage.getItem(\"feature:new-presets\") === \"true\";\n+\n+if (useNewPresets) {\n+  // Use new preset system\n+} else {\n+  // Use legacy system\n+}\n+\n+// 3. Version detection\n+const presetVersion = localStorage.getItem(\"preset-version\");\n+if (!presetVersion || presetVersion < \"1.0.0\") {\n+  // Use compatibility mode\n+}\n+```\n+\n+## Getting Help\n+\n+- **Documentation**: See the [Getting Started Guide](./getting-started.md)\n+- **API Reference**: Check the [API documentation](./api-reference.md)\n+- **Issues**: Report problems on [GitHub](https://github.com/your-repo/issues)\n+- **Support**: Contact support@example.com for enterprise customers\n+\n+## Migration Timeline\n+\n+1. **Phase 1** (Current): Filter preset system available as opt-in\n+2. **Phase 2** (v1.5): Deprecation warnings for old APIs\n+3. **Phase 3** (v2.0): Remove deprecated APIs\n+4. **Phase 4** (v2.x): Performance optimizations and new features\n+\n+Plan your migration accordingly to avoid breaking changes.\ndiff --git a/docs/filter-presets/troubleshooting.md b/docs/filter-presets/troubleshooting.md\nnew file mode 100644\nindex 0000000..0dcc4b3\n--- /dev/null\n+++ b/docs/filter-presets/troubleshooting.md\n@@ -0,0 +1,680 @@\n+# Troubleshooting Guide\n+\n+This guide covers common issues you might encounter when working with filter presets and their solutions.\n+\n+## Common Issues\n+\n+### Storage Quota Exceeded\n+\n+**Problem**: \"QuotaExceededError\" when trying to save presets.\n+\n+**Symptoms**:\n+\n+- Error message: \"Failed to save preset: storage quota exceeded\"\n+- New presets cannot be saved\n+- Existing presets may not update\n+\n+**Solutions**:\n+\n+1. **Check storage usage**:\n+\n+```typescript\n+const { getStorageInfo } = usePresetStorage();\n+\n+const info = await getStorageInfo();\n+console.log(`Using ${info.used} of ${info.quota} bytes`);\n+console.log(`${info.count} presets stored`);\n+```\n+\n+2. **Clean up old presets**:\n+\n+```typescript\n+// Delete presets older than 90 days\n+const { presets, deletePreset } = useFilterPresets({ gridApi });\n+\n+const threeMonthsAgo = Date.now() - 90 * 24 * 60 * 60 * 1000;\n+\n+for (const preset of presets) {\n+  if (preset.type === \"user\" && new Date(preset.updatedAt).getTime() < threeMonthsAgo) {\n+    await deletePreset(preset.id);\n+  }\n+}\n+```\n+\n+3. **Enable compression**:\n+\n+```typescript\n+const storage = createPresetStorage({\n+  adapter: \"localStorage\",\n+  compression: true, // Reduces size by 60-80%\n+});\n+```\n+\n+4. **Use IndexedDB for larger storage**:\n+\n+```typescript\n+const storage = createPresetStorage({\n+  adapter: \"indexedDB\", // Much larger quota (50MB+)\n+  dbName: \"FilterPresets\",\n+});\n+```\n+\n+### Presets Not Loading\n+\n+**Problem**: Saved presets don't appear or load incorrectly.\n+\n+**Common Causes**:\n+\n+- Browser privacy mode\n+- Cross-origin issues\n+- Corrupted storage data\n+- Version mismatches\n+\n+**Solutions**:\n+\n+1. **Check browser mode**:\n+\n+```typescript\n+function isPrivateMode(): boolean {\n+  try {\n+    localStorage.setItem(\"test\", \"test\");\n+    localStorage.removeItem(\"test\");\n+    return false;\n+  } catch (e) {\n+    return true;\n+  }\n+}\n+\n+if (isPrivateMode()) {\n+  console.warn(\"Private mode detected - presets may not persist\");\n+}\n+```\n+\n+2. **Validate storage data**:\n+\n+```typescript\n+async function validateAndRepairStorage() {\n+  try {\n+    const raw = localStorage.getItem(\"ag-grid-filter-presets\");\n+    if (!raw) return;\n+\n+    const presets = JSON.parse(raw);\n+    const validPresets = [];\n+\n+    for (const preset of presets) {\n+      const validation = validatePreset(preset);\n+      if (validation.isValid) {\n+        validPresets.push(validation.sanitized);\n+      } else {\n+        console.warn(\"Invalid preset found:\", validation.errors);\n+      }\n+    }\n+\n+    // Save back valid presets\n+    localStorage.setItem(\"ag-grid-filter-presets\", JSON.stringify(validPresets));\n+  } catch (error) {\n+    console.error(\"Storage validation failed:\", error);\n+    // Consider clearing corrupt data\n+    if (confirm(\"Preset data appears corrupted. Clear and start fresh?\")) {\n+      localStorage.removeItem(\"ag-grid-filter-presets\");\n+    }\n+  }\n+}\n+```\n+\n+3. **Handle version mismatches**:\n+\n+```typescript\n+const { presets, error } = useFilterPresets({\n+  gridApi,\n+  onError: (error) => {\n+    if (error.code === \"VERSION_MISMATCH\") {\n+      // Attempt migration\n+      return migratePresets(error.presets, error.fromVersion, CURRENT_VERSION);\n+    }\n+    throw error;\n+  },\n+});\n+```\n+\n+### URL Sharing Not Working\n+\n+**Problem**: Shareable URLs don't load the correct filters.\n+\n+**Common Issues**:\n+\n+- URL too long for some browsers/servers\n+- Special characters not properly encoded\n+- Hash fragments vs query parameters\n+\n+**Solutions**:\n+\n+1. **Use query parameters instead of hash**:\n+\n+```typescript\n+// Bad - hash fragments aren't sent to server\n+const url = `${location.origin}#preset=${encodedData}`;\n+\n+// Good - query parameters are more reliable\n+const url = `${location.origin}?p=${encodedData}`;\n+```\n+\n+2. **Implement URL shortening**:\n+\n+```typescript\n+async function createShortUrl(longUrl: string): Promise<string> {\n+  // For very long URLs, store the preset and use an ID\n+  if (longUrl.length > 2000) {\n+    const preset = parseShareableUrl(longUrl);\n+    const saved = await savePreset({\n+      ...preset,\n+      sharing: { enabled: true },\n+    });\n+\n+    return `${location.origin}?preset=${saved.id}`;\n+  }\n+\n+  return longUrl;\n+}\n+```\n+\n+3. **Handle URL parsing errors gracefully**:\n+\n+```typescript\n+function loadFromUrl() {\n+  try {\n+    const params = new URLSearchParams(location.search);\n+    const presetData = params.get(\"p\");\n+\n+    if (!presetData) return;\n+\n+    const decoded = decodeShareableUrl(presetData);\n+    if (decoded) {\n+      gridApi.setFilterModel(decoded.filterModel);\n+    }\n+  } catch (error) {\n+    console.error(\"Failed to load from URL:\", error);\n+\n+    // Show user-friendly message\n+    showNotification({\n+      type: \"error\",\n+      message: \"Unable to load shared filters. The link may be invalid or expired.\",\n+    });\n+  }\n+}\n+```\n+\n+### Import/Export Failures\n+\n+**Problem**: Preset import fails or exports are corrupted.\n+\n+**Common Causes**:\n+\n+- Invalid JSON format\n+- Character encoding issues\n+- File size limitations\n+\n+**Solutions**:\n+\n+1. **Validate JSON before import**:\n+\n+```typescript\n+async function importPresets(file: File) {\n+  try {\n+    const text = await file.text();\n+\n+    // Try to parse JSON\n+    let data;\n+    try {\n+      data = JSON.parse(text);\n+    } catch (e) {\n+      throw new Error(\"Invalid JSON format. Please check the file.\");\n+    }\n+\n+    // Validate structure\n+    if (!Array.isArray(data)) {\n+      throw new Error(\"Expected an array of presets\");\n+    }\n+\n+    // Validate each preset\n+    const validPresets = [];\n+    for (const preset of data) {\n+      const validation = validatePreset(preset);\n+      if (validation.isValid) {\n+        validPresets.push(validation.sanitized);\n+      }\n+    }\n+\n+    // Import valid presets\n+    return await importValidPresets(validPresets);\n+  } catch (error) {\n+    console.error(\"Import failed:\", error);\n+    throw error;\n+  }\n+}\n+```\n+\n+2. **Handle encoding issues**:\n+\n+```typescript\n+function exportPresets(presets: Preset[]): Blob {\n+  // Ensure proper UTF-8 encoding\n+  const json = JSON.stringify(presets, null, 2);\n+  const blob = new Blob([json], {\n+    type: \"application/json;charset=utf-8\",\n+  });\n+\n+  return blob;\n+}\n+\n+// For download\n+function downloadPresets(presets: Preset[]) {\n+  const blob = exportPresets(presets);\n+  const url = URL.createObjectURL(blob);\n+  const link = document.createElement(\"a\");\n+\n+  link.href = url;\n+  link.download = `filter-presets-${Date.now()}.json`;\n+  link.click();\n+\n+  // Clean up\n+  URL.revokeObjectURL(url);\n+}\n+```\n+\n+## Browser-Specific Issues\n+\n+### Safari Private Browsing\n+\n+Safari in private mode has very limited localStorage (0-1MB).\n+\n+**Solution**:\n+\n+```typescript\n+function getSafariPrivateStorage(): PresetStorageAdapter {\n+  // Use sessionStorage as fallback\n+  return {\n+    async getAll() {\n+      const data = sessionStorage.getItem(\"temp-presets\");\n+      return data ? JSON.parse(data) : [];\n+    },\n+\n+    async save(preset: UserPreset) {\n+      const presets = await this.getAll();\n+      presets.push(preset);\n+      sessionStorage.setItem(\"temp-presets\", JSON.stringify(presets));\n+    },\n+    // ... other methods\n+  };\n+}\n+\n+// Detect and use appropriate storage\n+const storage = isSafariPrivate() ? getSafariPrivateStorage() : createPresetStorage({ adapter: \"localStorage\" });\n+```\n+\n+### Firefox Tracking Protection\n+\n+Firefox's Enhanced Tracking Protection can block localStorage in some cases.\n+\n+**Solution**:\n+\n+```typescript\n+async function checkStorageAccess(): Promise<boolean> {\n+  if (\"storage\" in navigator && \"estimate\" in navigator.storage) {\n+    const { quota = 0 } = await navigator.storage.estimate();\n+    return quota > 0;\n+  }\n+\n+  // Fallback test\n+  try {\n+    const test = \"__storage_test__\";\n+    localStorage.setItem(test, test);\n+    localStorage.removeItem(test);\n+    return true;\n+  } catch {\n+    return false;\n+  }\n+}\n+\n+// Show warning if blocked\n+if (!(await checkStorageAccess())) {\n+  showWarning(\"Storage access appears to be blocked. \" + \"Please check your browser's tracking protection settings.\");\n+}\n+```\n+\n+### IE11 Compatibility\n+\n+For legacy browser support:\n+\n+```typescript\n+// Polyfill for Object.entries\n+if (!Object.entries) {\n+  Object.entries = function (obj: any) {\n+    return Object.keys(obj).map((key) => [key, obj[key]]);\n+  };\n+}\n+\n+// Use ES5-compatible storage\n+class LegacyStorage implements PresetStorageAdapter {\n+  getAll(): Promise<UserPreset[]> {\n+    return new Promise(function (resolve) {\n+      try {\n+        var data = localStorage.getItem(\"presets\");\n+        resolve(data ? JSON.parse(data) : []);\n+      } catch (e) {\n+        resolve([]);\n+      }\n+    });\n+  }\n+\n+  // ... other methods using ES5 syntax\n+}\n+```\n+\n+## Performance Issues\n+\n+### Slow Preset Loading\n+\n+**Problem**: Presets take too long to load or apply.\n+\n+**Solutions**:\n+\n+1. **Implement pagination**:\n+\n+```typescript\n+const { presets, loadMore, hasMore } = useFilterPresets({\n+  gridApi,\n+  pagination: {\n+    pageSize: 20,\n+    loadOnScroll: true,\n+  },\n+});\n+```\n+\n+2. **Use virtual scrolling for preset lists**:\n+\n+```typescript\n+import { FixedSizeList } from 'react-window';\n+\n+function PresetList({ presets, onSelect }) {\n+  return (\n+    <FixedSizeList\n+      height={400}\n+      itemCount={presets.length}\n+      itemSize={60}\n+      width=\"100%\"\n+    >\n+      {({ index, style }) => (\n+        <div style={style}>\n+          <PresetItem\n+            preset={presets[index]}\n+            onSelect={onSelect}\n+          />\n+        </div>\n+      )}\n+    </FixedSizeList>\n+  );\n+}\n+```\n+\n+3. **Defer complex operations**:\n+\n+```typescript\n+// Use requestIdleCallback for non-critical updates\n+function savePresetDeferred(preset: UserPreset) {\n+  if (\"requestIdleCallback\" in window) {\n+    requestIdleCallback(\n+      () => {\n+        storage.save(preset);\n+      },\n+      { timeout: 2000 },\n+    );\n+  } else {\n+    // Fallback to setTimeout\n+    setTimeout(() => {\n+      storage.save(preset);\n+    }, 100);\n+  }\n+}\n+```\n+\n+### Memory Leaks\n+\n+**Problem**: Memory usage increases over time.\n+\n+**Solutions**:\n+\n+1. **Clean up event listeners**:\n+\n+```typescript\n+useEffect(() => {\n+  const handleStorageChange = (e: StorageEvent) => {\n+    if (e.key === storageKey) {\n+      refreshPresets();\n+    }\n+  };\n+\n+  window.addEventListener(\"storage\", handleStorageChange);\n+\n+  // Important: Clean up\n+  return () => {\n+    window.removeEventListener(\"storage\", handleStorageChange);\n+  };\n+}, [storageKey]);\n+```\n+\n+2. **Limit cache size**:\n+\n+```typescript\n+class CachedStorage implements PresetStorageAdapter {\n+  private cache = new Map<string, UserPreset>();\n+  private maxCacheSize = 100;\n+\n+  async get(id: string): Promise<UserPreset | null> {\n+    // Implement LRU cache\n+    if (this.cache.has(id)) {\n+      const preset = this.cache.get(id)!;\n+      // Move to end (most recently used)\n+      this.cache.delete(id);\n+      this.cache.set(id, preset);\n+      return preset;\n+    }\n+\n+    const preset = await this.storage.get(id);\n+    if (preset) {\n+      this.addToCache(id, preset);\n+    }\n+\n+    return preset;\n+  }\n+\n+  private addToCache(id: string, preset: UserPreset) {\n+    if (this.cache.size >= this.maxCacheSize) {\n+      // Remove least recently used\n+      const firstKey = this.cache.keys().next().value;\n+      this.cache.delete(firstKey);\n+    }\n+    this.cache.set(id, preset);\n+  }\n+}\n+```\n+\n+## Migration Failures\n+\n+**Problem**: Presets from older versions don't work.\n+\n+**Solutions**:\n+\n+1. **Implement robust migration**:\n+\n+```typescript\n+async function migratePresets() {\n+  const stored = localStorage.getItem(\"ag-grid-filter-presets\");\n+  if (!stored) return;\n+\n+  try {\n+    const data = JSON.parse(stored);\n+    const version = data.version || \"1.0.0\";\n+\n+    if (version < CURRENT_VERSION) {\n+      console.log(`Migrating presets from ${version} to ${CURRENT_VERSION}`);\n+\n+      const migrated = await runMigrations(data.presets, version);\n+\n+      localStorage.setItem(\n+        \"ag-grid-filter-presets\",\n+        JSON.stringify({\n+          version: CURRENT_VERSION,\n+          presets: migrated,\n+        }),\n+      );\n+\n+      console.log(\"Migration completed successfully\");\n+    }\n+  } catch (error) {\n+    console.error(\"Migration failed:\", error);\n+\n+    // Backup old data\n+    localStorage.setItem(\"ag-grid-filter-presets.backup\", stored);\n+\n+    // Show user notification\n+    showNotification({\n+      type: \"warning\",\n+      message: \"Some saved filters may need to be recreated due to updates.\",\n+      action: {\n+        label: \"Restore Backup\",\n+        onClick: restoreBackup,\n+      },\n+    });\n+  }\n+}\n+```\n+\n+2. **Provide rollback option**:\n+\n+```typescript\n+function restoreBackup() {\n+  const backup = localStorage.getItem(\"ag-grid-filter-presets.backup\");\n+  if (backup) {\n+    localStorage.setItem(\"ag-grid-filter-presets\", backup);\n+    location.reload();\n+  }\n+}\n+```\n+\n+## Security Issues\n+\n+### XSS in Preset Names\n+\n+**Problem**: Malicious code in preset names executed when rendered.\n+\n+**Solution**:\n+\n+```typescript\n+// Always sanitize user input\n+import DOMPurify from 'isomorphic-dompurify';\n+\n+function sanitizePresetName(name: string): string {\n+  return DOMPurify.sanitize(name, {\n+    ALLOWED_TAGS: [], // No HTML allowed\n+    ALLOWED_ATTR: []\n+  });\n+}\n+\n+// Safe rendering\n+function PresetItem({ preset }) {\n+  return <div>{preset.name}</div>; // React escapes by default\n+}\n+\n+// If using innerHTML, always sanitize\n+function PresetDescription({ html }) {\n+  const sanitized = DOMPurify.sanitize(html, {\n+    ALLOWED_TAGS: ['b', 'i', 'br'],\n+    ALLOWED_ATTR: []\n+  });\n+\n+  return <div dangerouslySetInnerHTML={{ __html: sanitized }} />;\n+}\n+```\n+\n+## Debugging Tips\n+\n+### Enable Debug Logging\n+\n+```typescript\n+// Add to your app initialization\n+if (process.env.NODE_ENV === \"development\") {\n+  window.DEBUG_PRESETS = true;\n+}\n+\n+// In your preset code\n+function debugLog(...args: any[]) {\n+  if (window.DEBUG_PRESETS) {\n+    console.log(\"[Presets]\", ...args);\n+  }\n+}\n+\n+// Use throughout your code\n+debugLog(\"Saving preset:\", preset);\n+debugLog(\"Storage info:\", await getStorageInfo());\n+```\n+\n+### Storage Inspector\n+\n+```typescript\n+// Utility to inspect storage\n+window.inspectPresetStorage = async function () {\n+  const storage = createPresetStorage({ adapter: \"localStorage\" });\n+  const presets = await storage.getAll();\n+  const info = await storage.getInfo();\n+\n+  console.group(\"Preset Storage Inspector\");\n+  console.log(\"Storage Info:\", info);\n+  console.log(\"Preset Count:\", presets.length);\n+  console.table(\n+    presets.map((p) => ({\n+      id: p.id,\n+      name: p.name,\n+      created: new Date(p.createdAt).toLocaleDateString(),\n+      size: JSON.stringify(p).length,\n+    })),\n+  );\n+  console.groupEnd();\n+};\n+```\n+\n+### Performance Profiling\n+\n+```typescript\n+// Profile preset operations\n+async function profilePresetOperations() {\n+  const operations = [\n+    { name: \"Load All Presets\", fn: () => storage.getAll() },\n+    { name: \"Save Preset\", fn: () => storage.save(testPreset) },\n+    { name: \"Apply Preset\", fn: () => gridApi.setFilterModel(testModel) },\n+    { name: \"Generate URL\", fn: () => createShareableUrl(testPreset) },\n+  ];\n+\n+  for (const op of operations) {\n+    const start = performance.now();\n+    await op.fn();\n+    const duration = performance.now() - start;\n+    console.log(`${op.name}: ${duration.toFixed(2)}ms`);\n+  }\n+}\n+```\n+\n+## Getting Help\n+\n+If you encounter issues not covered here:\n+\n+1. **Check browser console** for error messages\n+2. **Enable debug logging** (see above)\n+3. **Test in incognito/private mode** to rule out extensions\n+4. **Try a different browser** to identify browser-specific issues\n+5. **Check the [GitHub issues](https://github.com/your-repo/issues)**\n+6. **File a bug report** with:\n+   - Browser version\n+   - Error messages\n+   - Steps to reproduce\n+   - Debug logs\n",
  "context": {
    "issue": 52,
    "branch": "feature/52-create-comprehensive-documentation-and-testing-sui",
    "worktree": "/Users/ryan/ag-grid-worktrees/feature/52-create-comprehensive-documentation-and-testing-sui",
    "createdAt": "2025-07-06T14:15:46.146Z",
    "status": "initialized",
    "lastCheckpoint": "2025-07-06T15:11:21.493Z",
    "checkpointMessage": "Completed all documentation tasks for filter presets feature. Created comprehensive guides covering Getting Started, API Reference, Advanced Topics, Troubleshooting, and Migration. Updated README with filter presets section. All linting issues resolved. Ready to start test implementation.",
    "checkpoints": 3
  }
}
